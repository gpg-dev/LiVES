= Technical Specification =

TODO: - plugin parameter interpolation
      - plugin easing
      - change "choices" to "display_values" ?


Weed API Version Changes
------------------------
100 - first release
110 - added WEED_PARAMETER_ELEMENT_PER_CHANNEL
120 - added WEED_YUV_CLAMPING and WEED_YUV_SUBSPACE
130 - added WEED_CHANNEL_RESIZE_ON_ROWSTRIDES_CHANGE
131 - added WEED_FILTER_PROCESS_LAST, removed WEED_COLORSPACE_HSV
132 - added threading hint, and later WEED_CHANNEL_ALPHA_PREMULT
133 - added gamma correction, package_name

200 - separated WEED_API_VERSION and WEED_FILTER_API_VERSION.

Updated WEED_API_VERSION to 200
  - added weed_leaf_flag_set(), weed_leaf_flag_get(). Filter API changes are listed below.
  - Added typedef for weed_realloc_f.

Possibly non-backwards compatible:
  - removed weed_leaf_set_caller(),
  - changed meaning of return value from weed_leaf_element_size() for WEED_SEED_VOIDPTR
  - WEED_SEED_VOIDPTR will now be cast to / from uint64_t instead of void *.
  - added WEED_VOIDPTR_SIZE, defined as sizeof(void *)
  - changed typedef for weed_size_t to be uint32_t, (replacing size_t in previous versions)
  - added typedef for weed_error_t as int32_t, (replacing int in previous versions)


Changelog:
21/04/06 salsaman.
Added notes about WEED_PLANT_UNKNOWN, clarified "max_repeats" for
filters, clarified number of elements in parameter_template
"default". Removed "TODO" from refs. to Weed EVENTS spec. Version number unchanged.

14/08/06 salsaman
Allow channels based on templates with "max_repeats" to be disabled at
any time, even if the template is not marked "optional". Version
number unchanged.

20/08/06 salsaman
Small change to description of "max_repeats". Number of channels may
only be _reduced_ after init(); and only by setting "disabled" to WEED_TRUE. Version
number unchanged.

22/08/06 salsaman
Added "new_default" leaf for parameter templates which have the
WEED_PARAMETER_VARIABLE_ELEMENTS flag set. Version number unchanged.

24/08/06 salsaman
Added "ignore" leaf for parameters for use in interpolation where the
"value" contains a list. Version number unchanged. Removed
WEED_PLANT_UNKNOWN since it is not part of the API.

24/09/06 salsaman
Corrected/clarified some parts of the text. API unchanged.

30/10/06 salsaman
Add host-only function weed_leaf_delete(). Since it is host only, API
version is unchanged.

11/12/06 salsaman
Added WEED_CHANNEL_FOLLOWS_OUTPUT and
WEED_PARAMETER_ELEMENT_PER_CHANNEL. Updated spec to 1.1 and API
version to 110.

13/12/06 salsaman
Add optional "target_fps" to filter_instance, change it from an array to a
single value. API version unchanged.

25/07/07 salsaman
Add filter flag WEED_FILTER_HINT_IS_POINT_EFFECT. API version unchanged.

27/03/08 salsaman
Corrected some typos and clarified about passing function pointers.

07/06/08 salsaman
Updated to libweed. Spec is now at version 3.0. Moved text around to split into Weed and
Weed Effects.

14/06/08 salsaman
Add YUV_clamping, YUV_subspace. Remove "h_shift" and "v_shift". Allow
generators to set channel sizes, but they should attempt to use the
host set size. Clarified some points. API version was updated to 120.

03/11/08 salsaman
Removed requirement that weed plugin file extensions be .wo, since this was discovered to be non-portable.

11/10/09 salsaman
Correct a typo, and try to further clarify about function passing.

31/10/09 salsaman
Correct WEED_FILTER_HINT_STATELESS -> WEED_FILTER_HINT_IS_STATELESS

9/11/09
Added WEED_CHANNEL_RESIZE_ON_ROWSTRIDES_CHANGE
API Version to 130

5/02/10 salsaman
Clarified text about default getter and bootstrap process.

7/02/10 salsaman
Removed WEED_COLORSPACE_HSV, deprecated WEED_FILTER_FOLLOWS_OUTPUT, 
added WEED_FILTER_PROCESS_LAST

16/04/10 salsaman
Clarified meaning of YUV_subspace

22/09/10 salsaman
Clarified YUV_subsampling, *changed value of default*.

21/10/10 salsaman
Clarified text about plugin data and icon directories.

17/03/11 salsaman
Switched WEED_FILTER_HINT_IS_POINT_EFFECT to WEED_FILTER_HINT_NO_THREADING **

6/08/11 salsaman
Corrected spelling error WEED_HINT_INT -> WEED_HINT_INTEGER

7/01/12 salsaman
Add clarifying notes about out parameters.

19/01/12 salsaman
Add channel flag WEED_CHANNEL_ALPHA_PREMULT. API unchanged.

23/01/12 salsaman
Clarified range for AFLOAT.

29/07/12 salsaman
** Corrected name of flag and description to WEED_FILTER_HINT_MAY_THREAD

15/11/12 salsaman
added clarifying remarks for number of values in parameter defaults.

01/03/13 salsaman
corrected description about static function versions

17/03/13 salsaman
added "extra_authors" leaf for plugin_info. Corrected description about static functions for plugins.
added "rowstride_alignment_hint" for channel templates.

17/09/2013 salsaman
Clarified description of "group" leaf for WEED_HINT_SWITCH parameter templates.

12/10/2013 salsaman
Add "hidden" option to filter_class gui.

30/09/2014 salsaman
Add missing type documentation for "fps".

04/03/2016 salsaman
Add optional "copyright" leaf to PLUGIN_INFO.


28/10/2019 salsaman
Version 2.0. Spec changes:
Added 2 new functions, weed_leaf_set_voidptr_sizes() and weed_leaf_get_all().
Allow plugins access to weed_plant_free().
Changed return value from weed_leaf_element_size() for WEED_SEED_VOIDPTR (now returns the data size rather than sizeof(void *)).
Added WEED_VOIDPTR_SIZE.
Added typedefs weed_error_t, weed_size_t, weed_voidptr_t.
Added typedefs weed_realloc_f, weed_calloc_f, weed_memmove_f.
weed_size_t is now int32_t rather than size_t.
Calling weed_leaf_get() for an existing leaf but with and invalid idx returns WEED_ERROR_NOSUCH_ELEMENT rather than
WEED_ERROR_NOSUCH_LEAF (BUGFIX).
Added WEED_ABI_VERSION (synonym for WEED_API_VERSION).
Added WEED_ERROR_IMMUTABLE and WEED_ERROR_UNDELETABLE.
Added WEED_FLAG_UNDELETABLE and WEED_FLAG_IMMUTABLE.


Filter API:
Added WEED_FILTER_API_VERISON, defined as 200 for this release.
Added WEED_ERROR_BADVERSION.
Added optional "flags" leaf to HOST_INFO.
Added WEED_GAMMA_UNKNOWN, WEED_GAMMA_LINEAR, WEED_GAMMA_SRGB (weed-palettes.h)
Added WEED_HOST_SUPPORTS_LINEAR_GAMMA flag bit for HOST_INFO "flags".
Added WEED_FILTER_HINT_LINEAR_GAMMA for FILTER_CLASS "flags"
Added definitions for WEED_GAMMA_UNKNOWN, WEED_GAMMA_LINEAR, WEED_GAMMA_SRGB.
Added optional "gamma_type" leaves to PARAMETER_TEMPLATE, PARAMETER, CHANNEL.
Moved typedef weed_timecode_t from weed.h
Removed WEED_LEAF_READONLY_PLUGIN, WEED_LEAF_READONLY_HOST and WEED_ERROR_LEAF_READONLY.



(C) Gabriel "Salsaman" Finch 2005 - 2019

With contributions by: Niels Elburg, Dennis "Jaromil" Rojo, Andraz
Tori, and Oyvind "Pippin" Kolas.

Weed is an object system developed for video/audio processing. Weed
currently has modules for video/audio effects (weed-effects), and for
timeline style events (weed-events).




== WEED_API_VERSION / WEED_ABI_VERSION ==

These equivalent preprocessor symbols are defined as 200 for this version of the specification. This
number may be increased for future revisions of the spec.

Note:
libweed-utils provides the following function:

  int check_weed_abi_compat(int32_t higher, int32_t lower)

which returns WEED_TRUE if the two versions are compatible, WEED_FALSE otherwise.
(or if either version is higher that the library version, since it can't know the future...)



=== General overview ===

Weed can be utilsed at different levels depending on the needs of the programmer.

Level 0: -a program would simply #include weed.h and may set the symbols #HAVE_WEED_PLANT, #HAVE_WEED_LEAF and #HAVE_WEED_DATA
At this level there is no definition of these items, however the core function types (listed below) are defined.
The fundament types are defined along with some error numbers and so on.



Level 1: an application #includes weed.h and uses the built-in type definitions weed_data_t, weed_leaf_T, weed_plant_t.
The application may now use the a reference implementation of libweed for all of the core functions. An application wishing to use
libweed just needs to call weed_init(int32_t api_level) to get the correct version of the functions for that api version.
In most cases you would just call weed_init(WEED_API_VERSION) and check that the returned value is not WEED_ERROR_BADVERSION.



Level 2: at this level we distinguish between plugins and hosts. The host program is normally the one which will dlopen()
or link with the plugins.

Hosts should #incldue weed-host.h before weed.h, amd plugins should instead #include weed-plugin.h

The main difference is that the plugin gets staticly scoped versions of the core functions,
whereas the host gets global ones.

Plugins also relinquish access to the weed_leaf_set_flags() function.



Level 3: at his level host and plugin may choose to use a utilities library such as weed-utils.
Only hosts should link with this library. Plugins simply need to include the weed-utils.h header.


There also a library (in development) which effects plugins may use, weed-plugin-utils.c



Level 4: host and pugins would be tailored to a particular role (multiple roles may be selected provide their symbols do not
conflict.)
For example for video plugins, host and plugins would #include weed-effects.h


Depending on the apllication type there may be other optional or mandatory headers.
For example, for video effects plugins, Weed offers the optional headers weed-palettes.h amd weed-compat.h

For weed events there is weed-events.h








== WEED PLANTS ==

A ''plant'' in Weed is a collection of one or more ''leaves''.

Each plant has one MANDATORY leaf, with the key WEED_LEAF_TYPE (defined as "" in weed.h).
Depending upon the value of this leaf, the plant may have other mandatory and optional leaves defined by an 
application specification.

"type" is a single valued leaf with seed_type WEED_SEED_INT (See below: seed_types).

The "type" is passed as a parameter in the weed_plant_new() function.
This function returns a pointer to newly allocated plant with the "type" leaf value set
to the plant_type.




== LEAVES ==

As mentioned above, each "plant" is simply a set of one or more "leaves".

Each leaf has at least:
 * a ''key'' a unique (for the plant) non-NULL ASCII string; cannot be changed once the leaf is created.

 * a ''value'' (an array of 0 or more elements, the type depends on the seed_type of the leaf)

 * ''number of elements'' (weed_size_t) contained in the value field.

 * a ''seed_type'' (int32_t). Defines the type of the value field. Cannot be altered after the leaf is created.

 * a bitmap ''flags'' field (int32_t)





== SEED TYPES ==

The "seed type" denotes the type of the value field in a leaf.
Weed provides the following 'fundamental' types:

 * WEED_SEED_INT     [1] : equivalent to a signed /unsigned 32 bit integer. size = 4 bytes

 * WEED_SEED_DOUBLE  [2] : equivalent to a 64 bit signed double. size = 8 bytes

 * WEED_SEED_BOOLEAN [3] : signed /unsigned 32 bit integer, acceptable values are WEED_FALSE or WEED_TRUE. size = 4 bytes 

 * WEED_SEED_STRING  [4] : 0 terminated array of char (max length is uint32_max). (char *)NULL is treated as a zero length string.
   		     	   size = strlen(value)

 * WEED_SEED_INT64   [5] : signed /unsigned 64 bit integer . size = 8 bytes




 * WEED_SEED_FUNCPTR    [64]  : corresponds to a function pointer. In the case of getting / setting values, the address of a variable
                                or an array holding the function pointer should be used.
				Size == WEED_FUNCPTR_SIZE

'''Pointer''' types (number > 64) Size = WEED_VOIDPTR_SIZE.

 * WEED_SEED_VOIDPTR    [65]  : corresponds to a C void * type.


 * WEED_SEED_PLANTPTR   [66]  : a pointer to another weed plant.
   			   

Types >= 65536 are reserved for custom use. Custom seeds MUST be pointer types.



== WEED CORE FUNCTIONS ==

 * weed_plant_t *weed_plant_new (int32_t plant_type) : allocates and returns a new Weed plant
   with a single leaf, "type" with a single elemnt of WEED_SEED_INT, value set to plant_type.
   In case of memory error, the plant will not be created and NULL shall be returned.





 * weed_error_t weed_leaf_set (weed_plant_t *plant, const char *key, int32_t seed_type, weed_size_t num_elems, void *values)

    Set leaf values and number of elements.

    If plant is NULL, the function shall return WEED_ERROR_NOSUCH_LEAF.
    If key is NULL or zero length, it is equivalent to setting the "type" leaf.

    IF seed_type is not a pointer / funcptr type (>= 64) and not one of the fundamental types,
    then WEED_ERROR_WRONG_SEED_TYPE is returned and the leaf is not created or altered.

    If the leaf already exists and has a different seed_type then WEED_ERROR_WRONG_SEED_TYPE will be returned and the value
    will not be updated.
    
    values should be pointer to an array of the appropriate type and array size, cast to a void *

    for WEED_SEED_INT, values should be (void *)(int32_t[num_elems]) or (void *)(unt32_t[num_elems])
    for WEED_SEED_DOUBLE, values should be (void *)(double[num_elems])
    for WEED_SEED_BOOLEAN, values should be (void *)(int32_t[num_elems])
    for WEED_SEED_INT64, values should be (void *)(int64_t[num_elems])
    for WEED_SEED_STRING, it should be (void *)(char *[num_elems]),
    for WEED_SEED_FUNCPTR, (void *)(weed_funcptr_t[num_elems])
    for WEED_SEED_VOIDPTR, (void *)(weed_voidptr64_t[num_elems])
    for WEED_SEED_PLANTPTR, (void *)(((weed_voidptr64_t)(weed_plant_t *))[num_elems])
    custom types (seed_type >= 65536) would be similar to WEED_SEED_PLANTPTR, but with a different seed_type.

    The values array is assumed to be of the correct size and type.

    If the leaf does not exist in the plant, then it will be created and added to the plant, otherwise the value and array size
    of the existing leaf will be amended and the old data will be freed.


    If num_elems is 0 then only the seed_type is set (or checked if the leaf already exists),
    and while in this state any attempts to retrieve the value with weed_leaf_get() shall return WEED_LEAF_NOSUCH_ELEMENT.
    This is useful if you want to fix the seed_type of a leaf without setting any particular value.

    Passing a NULL pointer for values and num_elems > 0 will likely lead to undesired behaviour.

    In case of a memory error, WEED_ERROR_MEMORY_ALLOCATION is returned, and either the leaf is not created,
    or if it already exists then its num_elems is set to zero and its value to NULL.


    (as of API 200) If the WEED_FLAG_IMMUTABLE flag bit is set for the leaf, then WEED_ERROR_IMMUTABLE
    is returned and the leaf is not altered.

    Note:
    Attempting to set the number of elements of the "type" leaf to a value other than 1 will result in WEED_ERROR_NOSUCH_ELEMENT
    being returned and the value will not be altered.





* weed_error_t weed_leaf_get (weed_plant_t *plant, const char *key, int32_t idx, void *value) :

    returns the nth (starting from 0) element of the specified leaf.

    value should be typecast to a (void *) from a pointer of the appropriate type, depending on the seed_type of the leaf.
    (If the seed_type is not known, it should be retrieved first with weed_leaf_get_seed_type()).

    For WEED_SEED_INT it should be (void *)(int32_t *) or (void *)(uint32_t *).
    For WEED_SEED_DOUBLE it should be (void *)(double *)
    For WEED_SEED_BOOLEAN it should be (void *)(int32_t *)
    For WEED_SEED_INT64 it should be (void *)(int64_t *)
    For WEED_SEED_STRING, a (void *)(char **),
    for WEED_SEED_FUNCPTR, (void *)(weed_funcptr_t *),

    for WEED_SEED_VOIDPTR (void *)(weed_voidptr64_t *),
    for WEED_SEED_PLANTPTR (void *)(*((weed_voidptr64_t)(weed_plant_t *)))

    custom types (>= 65536) would be similar to WEED_SEED_PLANTPTR but with a different seed_type.

    If if the leaf does not exist, or plant is NULL, WEED_ERROR_NOSUCH_LEAF is returned.
    If key is NULL or zero length, it is equivalent to getting the "type" leaf.

    If the leaf exists but the element does not exist, then WEED_ERROR_NOSUCH_ELEMENT is returned.
    Note: prior to API version 200, this would erroneously return WEED_ERROR_NOSUCH_LEAF. In the unlikely case that this behaviour
    is still required (e.g. for backwards compatibility), then set the api version < 200 in weed_init().

    the value of the leaf element will be copied to value (IF value is non-NULL) using standard memcpy(),
    and WEED_SUCCESS will be returned.

    Note:
    For WEED_SEED_STRING, it may be necessary to first call weed_leaf_element size()
    and allocate a char array of at least the returned value + 1 (to hold the terminating NUL) in which to receive the value.

    
    Note:
    It is not a programming error to pass in a NULL pointer for value. In this case, Weed will not attemt to copy to value, but will
    still return an error code: either WEED_SUCCESS, WEED_ERROR_NOSUCH_LEAF or WEED_ERROR_NOSUCH_ELEMENT.

    thus by calling:      weed_leaf_get(plant, key, 0, NULL),
    it is possible to check whether a leaf exists, and whether it has a value set.
    - if the leaf doesn't exist, then WEED_ERROR_NOSUCH_LEAF will be returned.
    - if the value of the leaf is NULL, then number of elements should be 0, and WEED_ERROR_NOSUCH_ELEMENT will be returned
    - if the value of the leaf has 1 or more elements, then WEED_SUCCESS will be returned.

   If you just want to check whether a leaf exists or not, it may be simpler to call weed_leaf_seed_type() and test if it
   returns WEED_SEED_INVALID. If you just want to check if it exists and has a value, you can call
   weed_leaf_num_elements() and test if the returned value is > 0.




* weed_error_t weed_leaf_delete (weed_plant_t *plant, const char *key)
   remove the specified leaf from the plant, and free it

   [prior to API 200, this function was not avaiable to plugins]

   if the plant is NULL or the leaf does not exist, WEED_ERROR_NOSUCH_LEAF is returned.
   If key is NULL or zero length, it is considered equivalent to trying to delete the "type" leaf.

   if the WEED_FLAG_UNDELETABLE flag bit is set then WEED_ERROR_UNDELETABLE is returned, and the leaf is not deleted.

   For leaves with seed type WEED_SEED_STRING, the data is freed for each non NULL element.

   The "type" leaf of a plant may only ever be deleted via weed_plant_free(). If you attempt to delete it with weed_leaf_delete()
   then either WEED_ERROR_UNDELETABLE will be returned (if the WEED_FLAG_UNDELETABLE bit is set for it),
   otherwise WEED_ERROR_NOSUCH_LEAF will be returned.
   (Note the normal order of precedence of errors is here reversed: WEED_ERROR_NOSUCH_LEAF would normally
   be returned BEFORE WEED_ERROR_UNDELETABLE).

   The flag bit WEED_FLAG_IMMUTABLE is ignored in this function.




* weed_size_t weed_leaf_num_elements (weed_plant_t *plant, const char *key)
   - returns the number of elements for the specified leaf.

   if the leaf does not exist or the plant is NULL, returns 0. Since it is possible to create leaves with 0 elements,
   this is not a good method to use to check whether a leaf exists or not. If you want to do this you should use
   weed_leaf_get_seed_type (as described below), or weed_leaf_get() with value set to NULL as described above.

   If key is NULL or zero length, it is considered equivalent to the "type" leaf.




 * weed_size_t weed_leaf_element_size (weed_plant_t *plant, const char *key, int32_t idx)

   If the plant is NULL, the leaf does not exist, or idx is out of range, (weed_size_t)0 will be returned.

   If key is NULL or zero length, it is considered equivalent to the "type" leaf.

   For WEED_SEED_STRING, returns the string length in bytes (without any terminating NUL); equivalent to strlen().

   if the seed_type is WEED_SEED_VOIDPTR or WEED_SEED_FUNCPTR and the value is NULL, weed_size_t(0) is returned.
   otherwise it will return WEED_VOIDPTR_SIZE or WEED_FUNCPTR_SIZE respectively.

   For all other seed types, returns sizeof(seed_type), (e.g. for WEED_SEED_INT, returns 4, for WEED_SEED_INt64, returns 8).
   




 * int32_t weed_leaf_seed_type(weed_plant_t *plant, const char *key) : get the seed_type for a leaf

   Returns the seed_type for a leaf. If the plant is NULL or the leaf does not exist, will return WEED_SEED_INVALID.
   If key is NULL or zero length, it is considered equivalent to the "type" leaf.

   This fact can be used to check whether a leaf exists or not (provided plant is non-NULL). If you want to differentiate
   between leaves that have values or not, you should call weed_leaf_num_elements() and test if the returned value is > 0,
   or use the weed_leaf_get() method described above.





 * int32_t weed_leaf_get_flags(weed_plant_t *plant, const char *key) : get the flags for a leaf

   If plant is NULL or the leaf does not exist, (int32_t)0 will be returned.

   Otherwise the value of the leaf flags is returned.

   If key is NULL or zero length, it is considered equivalent to the "type" leaf.





 * weed_error_t weed_plant_free (weed_plant_t *plant) :

   returns error WEED_ERROR_UNDELETABLE if the "type" flag has WEED_LEAF_UNDELETABLE set, and nothing will be freed.

   If the plant is NULL the function simply returns WEED_SUCCESS.

   otherwise, any leaves which do NOT have the WEED_FLAG_UNDELETABLE bit set will be freed in a similar fashion to weed_leaf_delete()

   if all of the leaves except the "type" leaf were deleted, and the "type" leaf does not have the WEED_FLAG_UNDELETABLE bit set,
   the "type" leaf will be deleted and the plant is therefore freed.
   Im this case WEED_SUCCESS is returned.
   
   If leaves other than the type leaf remain (because they were undeletable), the "type" leaf is not freed, and
   WEED_ERROR_UNDELETABLE is returned. In this case it will be necesssary to clear the WEED_FLAG_UNDELETABLE
   flag bit from the remaining leaves (e.g with weed_plant_list_leaves() and weed_leaf_set_flags()),
   before calling weed_plant_Free() a second time.

   To recap:

   If the "type" leaf has the WEED_FLAG_UNDELETABLE bit set, no leaves will be deleted, and WEED_ERROR_UNDELETABLE is returned.

   If any of the other leaves have the flag bit set, neither they nor the "type" leaf will be deleted and
   WEED_ERROR_UNDELETABLE is returned.

   if none of the leaves have the WEED_FLAG_UNDELETABLE flag bit set, all the leaves will be deleted and WEED_SUCCESS returned.

   Note that as with weed_leaf_delete(), the flag bit WEED_FLAG_IMMUTABLE is ignored in this function.



 * char **weed_plant_list_leaves (weed_plant_t *plant)
   returns a (char *)[] array of leaf keys, with the final element set to NULL.

   In case of memory error, NULL is returned and the array is not created.

   The caller should free any non-NULL elements when no longer required.

   If plant is NULL, the function returns a char ** array of size one, with the single elemnt set to (char *)NULL.

   The standard malloc(), memcpy() and free() functions will be used when creating the array and all the strings.




A Weed host has access to an additional function which is not available to plugins:

 * weed_error_t weed_leaf_set_flags(weed_plant_t *plant, const char *key, int32_t flags)

   If key is NULL or zero length, it is considered equivalent to the "type" leaf.

   Caution ! Clearing the WEED_FLAG_IMMUTABLE bit for the "type" leaf allows the plant type to be changed !

   Setting the WEED_FLAG_UNDELETABLE bit for the "type" leaf prevents ANY leaves from being freed
   using weed_plant_free().

   Setting the WEED_FLAG_UNDELETABLE bit for any other leaf prevents the "type" leaf and that leaf from being freed
   using weed_plant_free().

   Setting the WEED_FLAG_UNDELETABLE bit for any leaf prevents that leaf from being deleted
   using weed_leaf_delete().

   Will return WEED_ERROR_NOSUCH_LEAF if the plant is NULL or leaf does not exist.






As of API 200: (TODO):


 * weed_error_t weed_leaf_get_all (weed_plant_t *plant, const char *key, int32_t *seed_type, weed_size_t *num_elems,
   weed_voidptr_t values, weed_size_t **sizes, int32_t *flags)

 Retrieves the num_elements, values, sizes and flags for the specified leaf.
 "values" should be cast to an array of the appropriate type (depending on the seed type) and freed after use, along with
 any string values retrieved. Any of the fields may be NULL (except for plant).
 Will return WEED_SUCCESS, WEED_ERROR_NOSUCH_LEAF or WEED_ERROR_MEMORY_ALLOCATION.

 If key is NULL, then values will be a NULL terminated array of the leaves (similar to weed_plant_list_leaves()),
 seed_type will be set to the plant type; num_elems to the length of the values array (minus the final NULL); sizes will hold
 the number of elements in each leaf, and flags will be set to the flags for the "type" leaf. All returned arrays should be freed
 after use, plus all the (string) values (except the final NULL).

 The standard malloc(), memcpy() amd free() functions will be used when creating the values array. 

 Will return WEED_SUCCESS or WEED_ERROR_MEMORY_ALLOCATION. In case of memory allocation error both the sizes and values arrays will
 be freed and set to NULL.







== LEAF FLAGS ==

Two special flag bits are defined in weed.h:

WEED_FLAG_UNDELETABLE [1 << 0] :: the leaf cannot be deleted, weed_leaf_delete will return WEED_ERROR_UNDELETABLE if you try it

and

WEED_FLAG_IMMUTABLE [1 << 1] :: the leaf value cannot be changed (but it may be deleted),
                                   weed_leaf_set returns WEED_ERROR_IMMUTABLE if you try to do so


When creating a new plant, libweed automatically will set the WEED_LEAF_IMMUTABLE flag for the "type" leaf.
Thus if you want to change the plant type, you must first clear the WEED_LEAF_IMMUTABLE flag bit, e.g.

int32_t flags = weed_leaf_get_flags(plant, WEED_LEAF_TYPE);
weed_error_t error = weed_leaf_set_flags(plant, WEED_LEAF_TYPE, flags ^ (flags & WEED_FLAG_IMMUTABLE));
if (error == WEED_SUCCESS) {
...
// now you can change the "type" of the plant




If the "type" leaf is set undeletable, then no leaves will be freed using weed_plant_free(),
the function will return WEED_ERROR_UNDELETABLE. In this case you need to clear the flag bit prior to calling weed_plant_free().

The combination of immutable and undeletable flag bits is designed so that Weed hosts can prevent plugins from
changing readonly values or freeing plants which are still referenced by the host.


Flag bits 0 - 15 are reserved for use by the Weed library. The remaining flag bits may be freely used by applications.




== WEED CORE ERRORS ==
Defined in weed.h

Errors are listed here in order of precedence from highest to lowest.

 *  WEED_SUCCESS[[BR]]
 *  WEED_NO_ERROR[[BR]]
    returned if no errors occured.

 *  WEED_ERROR_NOSUCH_LEAF[[BR]]
    leaf does not exist for the specified plant; returned from
    weed_leaf_get(), weed_leaf_delete(), weed_leaf_set_flags().

 *  WEED_ERROR_NOSUCH_ELEMENT[[BR]]
    plugin/host tried to read value of an invalid element number in a leaf; returned from weed_leaf_get()

 *  WEED_ERROR_WRONG_SEED_TYPE[[BR]]
    returned from weed_leaf_set() if the leaf has the WEED_FLAG_IMMUTABLE bit set

 *  WEED_ERROR_IMMUTABLE[[BR]]
    returned from weed_leaf_set() if you try to alter the value of a leaf which has the WEED_FLAG_IMMUTABLE bit set

 *  WEED_ERROR_UNDELETABLE[[BR]]
    returned if you try to delete a leaf which has the WEED_FLAG_UNDELETABLE bit set, or if weed_plant_free() finds any leaves
    with this flag bit set

*   WEED_ERROR_BADVERSION [[BR]]
    returned from weed_init() if the host specifies an api version that the library cannot support.

 *  WEED_ERROR_MEMORY_ALLOCATION[[BR]]
    memory allocation has failed



Error numbers >= 65536 are reserved for custom errors.








---- Weed reference build  -----

The reference build consists of two parts, a header (weed.h) and a library. Use of the library is optional, but requires
inclusion of the header.



--- weed.h ---

Typedefs:


The header provides typedefs for all the core functions.
e.g. weed_leaf_get_f, weed_malloc_f.

weed_funcptr_t is tpypedef as void (*weed_funcptr_t)()
weed_voidptr_t is typedefed as (void *)
weed_size_t is typedefed as (uint32_t)
weed_error_t is typedefed as (int32_t)



== Plant types ==

weed.h defines only a single plant type, WEED_PLANT_UNKNOWN, with value 0.


==== Other symbols ====

WEED_TRUE is #defined as 1 in the header.

WEED_FALSE is #defined as 0 in the header.

WEED_API_VERSION is #defined as 200 in the header.

WEED_API_VERSION_200 is also #defined in the header.

WEED_ABI_VERSION is #defined as 200 in the header.

WEED_ABI_VERSION_200 is also #defined in the header.

WEED_VOIDPTR_SIZE is #defined as (sizeof(void *))

WEED_FUNCPTR_SIZE is #defined as (sizeof(weed_funcptr_t))



== Leaf keys ==
weed.h defines the following leaf keys:


WEED_LEAF_TYPE "type"  : Mandatory leaf for all plants

WEED_LEAF_WEED_API_VERSION  : "weed_api_version"
WEED_LEAF_WEED_ABI_VERSION  : "weed_api_version"

Provided for convenience for use by any plant type






== Weed library functions  ==

There now follows a description of the Weed reference library (libweed). Currently this library is offered in two versions,
one using the standard memory functions, and a second using glib's slice allocator for higher performance (libweed-gslice)



== GETTING/SETTING LEAF VALUES ==

For WEED_SEED_STRING, libweed will allocate a new string when getting / setting the value. For all other seed_types,
copy is by reference.



== COMPILING WITH WEED ==

In order to use the reference build of Weed, a program should #include

weed/weed.h


and optionally link with libweed (libweed-gslice).


Some uses of Weed (e.g for effects plugins or events may require further headers, see below for an example).







== Weed_init() ==

   Prior to calling any other weed functions, a program (host, but not a plugin) must call:

 * weed_error_t weed_init(int32_t api_version)

     The application passes in the API version it wants to use. The function will set function
     pointers to the correct API versions of the core functions. Usually the program would use WEED_API_VERSION defined in
     weed.h

     If the host selects an API version < 100 or > the highest version the library supports, WEED_ERROR_BADVERSION will
     be returned, otherwise WEED_SUCCESS is returned.



== Pre-processor symbols ==
The Weed header checks for the following pre-processor symbols:

==== HAVE_WEED_PLANT_T ====

The reference implementation provides default
implementations of a Weed plant. This can be overriden at compile time using:
{{{
#define HAVE_WEED_PLANT_T
}}}
before
{{{
#include <weed/weed.h>
}}}

This need only be done in the host.
In this way a host can provide its own defintion of a Weed plant, and
provide its own implementation of the core functions, whilst still making
use of the rest of the header file.

HAVE_WEED_LEAF_T and HAVE_WEED_DATA_T allow for finer levels of overloading.









== WEED EFFECTS EXAMPLE ==

Since the main purpose of Weed is for video effects, a description is
included here, as an example of how Weed can be used.

There is also a Weed Audio Extension, and a Weed Events Extension,
which are documented separately.


== WEED_FILTER_API_VERSION  ==

This preprocessor symbol is defined as 200 for this version of the specification. This
number may be increased for future revisions of the spec.

libweed-utils provides the following function:

  int check_filter_api_compat(int32_t higher, int32_t lower)

which returns WEED_TRUE if the two versions are compatible, WEED_FALSE otherwise.




Weed Effects (and Event) plugins, the value of the plant leaf "type" MAY be one of:

  * WEED_PLANT_HOST_INFO          : Information about host and core functions
  * WEED_PLANT_PLUGIN_INFO        : Information about plugin and list of filter classes it includes
  * WEED_PLANT_FILTER_CLASS       : Descriptive information about single filter class
  * WEED_PLANT_CHANNEL_TEMPLATE   : Information about what kinds of channels filter accepts
  * WEED_PLANT_PARAMETER_TEMPLATE : Information about what kinds of parameters filter has
  * WEED_PLANT_FILTER_INSTANCE    : All data about an instance
  * WEED_PLANT_CHANNEL            : Instantiation of a channel
  * WEED_PLANT_PARAMETER          : Instantiation of a parameter

  * WEED_PLANT_GUI                : Used for GUI hints for the
                                    filter_classes and parameter_templates.



  * WEED_PLANT_EVENT              : plant used for events (described
                                            in the Weed EVENTS extension
  * WEED_PLANT_EVENT_LIST         : plant used for event lists (described
                                            in the Weed EVENTS extension





== WEED UTILITY FUNCTIONS ==

To make life easier for host and plugin writers, there exists a Weed
utility library, which wraps some of the core functions in simpler
variants. This is documented in the Weed Utility Library spec. (TODO).

== COMPILING A PLUGIN HOST WITH WEED ==

A host (ie. the application which will dlopen() the plugins)
wishing to use the reference build of Weed should #include the following headers:

weed/weed-host.h // BEFORE weed.h
weed/weed.h

and link with libweed

If the host wishes to use the Weed effects system:

weed/weed-effects.h

If using video effects:
weed/weed-palettes.h // before or after any other headers

If the host makes use of the Weed Utility Library, it may also be 
linked (shared or static) with libweed-utils, and #include weed/weed-utils.h

If the host wishes to use Weed events, it should #include weed/weed-events.h

weed-compat.h is provided for compatibily with some external libraries (see below).



== COMPILING A PLUGIN WITH WEED ==

An effects plugin wishing to use the reference build of Weed should #include the following headers:

weed/weed-plugin.h // BEFORE weed.h
weed/weed.h
weed/weed-effects.h // AFTER weed.h

and for a video effect:
weed/weed-palettes.h // before or after any other headers

TODO:
If plugins wish to use weed-utils then they should #include weed/weed-utils AFTER weed-plugin.h.

Plugins may optionally be link with libweed-plugin (TODO) and if they wish to use Weed utils they should simply
#include weed/weed-utils.h

Plugins should NOT be linked directly with libweed or libweed-utils, as they would be using the host version of the core
functions.



== WEED-COMPAT.H ==
weed/weed-compat.h is an optional include, provided for compatibility with some external libraries.
It will automatically include weed/weed-palettes.h if necessary

It will #define WEED_COMPAT_VERSION

If you #define NEED_FOURCC_COMPAT before calling it, then it will provides the following function:

int fourccp_to_weedp(unsigned int fourcc, int bpp, int *interlaced, int *sampling, int *sspace, int *clamping)
which will attempt to return a weed palette from an input fourcc code and bpp
- bpp is the pixel size in bits, currentl only 24 and 32 are recognised (e.g 24 for RGB, 32 for RGBA)

interlaced will be set to 1 if the palette is interlaced, otherwise 0
sampling will return the YUV sampling (or WEED_YUV_SAMPLING_DEFAULT if it could not be ascertained)
sspace will return the YUV subspace e.g. WEED_YUV_SUBSPACE_YCBCR, WEED_YUV_SUBSPACE_BT709
clamping will return the YUV clamping type, WEED_YUV_CLAMPING_CLAMPED or WEED_YUV_CLAMPING_UNCLAMPED

as of WEED_COMPAT_VERSION 0.11.0 it will also #define WEED_FOURCC_COMPAT in this case.



The header also provides compatibility with other libraries, eg. libav. Check the header for details.



=== functions ===
The folowwing functions are defined in weed-effects.h:


== PLUGIN FUNCTIONS ==

The only fixed function name the plugin MUST implement is weed_setup(), with prototype:

    weed_plant_t *weed_setup(weed_bootstrap_f weed_bootstrap)

The host calls this first in a plugin, and passes in a pointer to a function of type weed_bootstrap_f.


The prototype of weed_bootstrap_f is:

    weed_plant_t *weed_bootstrap(default_getter_f *, int32_t weed_api_min_version, int32_t weed_api_max_version,
     int32_t weed_filter_api_min_version, weed_filter_api_max_version);



The plugin should call the bootstrap function which should check the versions are compatible with the host, set up the plugin
versions of the core Weed functions using default getter, and return either a PLUGIN_INFO plant or NULL.


The precise details of this are described below. weed-plugin-utils.h provides macros to assist with this. A plugin need only do:

WEED_SETUP_START(int weed_api_version, int filter_api_version)

e.g.

WEED_SETUP_START(200, 200) { // either sets weed_plant_t *plugin_info, or returns NULL to the host
// set up plugin_info


// .....


// no return necessary
}
WEED_SETP_END;  // returns plugin_info to the host. may be positioned before or after the closing brace. The semi-colon is optional


WEED_SETUP_START also ensures that the weed_setup() function is exported from the plugin on any platform.




If the plugin supports earlier versions than the current version, e.g. when being updated, it may instead use:


WEED_SETUP_START_MINMAX(int min_weed_api_version, int max_weed_api_version, int min_filter_api_version, int max_filter_api_version)

The original values (or higher) should then be used as the minimum versions, and the maximum versions set to the current versions
at the time of the update.

In this case the plugin should then check the versions returned from the host to discover which features are available at run time.







( NB: prior to API version 200, the bootstrap function had a slightly different prototype:
   weed_plant_t *weed_bootstrap_func (default_getter_f *value, int32_t num_versions, int32_t *plugin_versions) )





==== weed_desetup ====
This is an optional function in for plugins.

    void weed_desetup(void);



If the plugin has this function, the host should call it before
unloading the plugin. This is to allow the plugin to reset any hardware, free allocated memory, etc.

The plugin MUST NOT free any of the standard plants (host_info, plugin_info, filter_classes, channel_templates,
parameter_templates, gui), that job is left to the host to perform.


weed-plugin-utils.h also provides macros to wrap this function:


WEED_DESETUP_START {

// clean up here

//

}
WEED_DESETUP_END; // may be positioned before or after the closing brace. The semi-colon is optional



WEED_DESETUP_START also ensures that the weed_desetup() function is exported from the plugin on any platform.




==== init_func ====


    weed_error_t init_func(weed_plant_t *filter_instance)


This is an optional function in the plugin.


If this function is included in the filter_class (see below),
the host MUST call this function exactly once before it can start to use process_func().
passing in the filter_instance to be used there.

The filter plant instance passed to the init_func MUST have been
correctly setup to match the filter class it relates to, 
this means that all the mandatory leaves of input and output channels and of input parameters MUST be set.
The function returns a weed error code (see below).

The init_func() function allows the plugin to create any internal
memory structures it needs; the plugin can store internal data as
leaves that have keys prefixed with "plugin_" in the filter_instance 
(see the definition of filter instance plant). The plugin can also (re)set
the "gui" settings for parameter_templates (see below).

The function returns WEED_SUCCESS or another error code (see below). 



==== process_func ====

   weed_error_t process_func(weed_plant_t *filter_instance, weed_timestamp_t timestamp)

This is an optional function in the plugin, however without it the plugin cannot process any data.
Ths host may call this as often as it wishes after calling the init_func (if it exists).

Host calls this for each processing cycle; the plugin should process the in parameters and in channels (as appropriate) and
produce data in the out channels and out parameters (as appropriate).

Timestamp is nominally in units of 10 ^ -8 of a second since playback started.
Normally it will increase monotonically for each frame but that is not guaranteed,
although hosts should attempt to keep it so between calling init_func() and deinit_func().

The function returns WEED_SUCCESS or another error code (see below). 



==== deinit_func ====
This is an optional function in the plugin. If present, the host must call it once after running the init_func and completing
the processing run.


    weed_error_t deinit_func(weed_plant_t *filter_instance)


The host will call this once after it has finished running the process_func()
to allow the plugin to free() any internal memory and reset its internal values.

Following this the host may call the init_func() again if it wishes to continue using the plugin,
otherwise it may call the desetup function and then free the host_info, plugin_info and any filter_instance plants.

The plugin MUST NOT free any of the standard plants (host_info, plugin_info, filter_classes, channel_templates,
parameter_templates, gui), that job is left to the host to perform.




Less commonly used functions:



==== interpolate_func ====
T.B.D

==== display_func ====
(deprecated)





== HOST FUNCTIONS ==

The host provides just one mandatory function to the plugins:
weed_bootstrap (see above for its definition).

The bootstrap function takes a list of Weed api versions supported by the
plugin, sets a getter function, and returns a host_info plant, or NULL
if none of the plugin api versions are supported.

The plugin can use the getter function to get the leaves of the host
info plant.

The HOST_INFO plant can also have other optional leaves to provide
more information about the host, and optional functions.






=== Re-entrancy ===

Plugins should be re-entrant, i.e the host should be able to create multiple instances from the filter class,
provided each instance follows the rules for init_func(), process_func(), deinit_func().

This means that a plugin should only maintain data common to all instances locally. The data for each separate instance
should be stored inside the instance itself.

If this is not possible for the filter class, the plugin should return WEED_ERROR_TOO_MANY_INSTANCES.




=== Multiple filters in one plugin ===

A plugin may provide multiple filters amd include them all as an array in the plugin_info.

Each filter should have its own set of in_parameter_templates, out_parameter_templates,
in_channel_templates and out_channel_templates and any related gui plants.

(See below for more details).


It should be noted that to assist with this, weed-plugin-utils offers a function:

* weed_clone_plants

which takes as input an array of plants and produces a copy, including producing new gui plants. as appropriate.


== PLANT TYPES ==

There now follows a description of the various plant types for weed effects, 
and their mandatory and optional leaves.



== PLANT TYPE HOST_INFO ==

This plant is created and returned in the weed_bootstrap function which the plugin must call from its weed_setup().

If weed_boostrap() from the weed-utils library is passed as the parameter to weed_setup(),
then the host_info will be created automatically using default values.

The host gains access to this plant either by providing its own weed_bootstrap, or by using the one from libweed-utils and
setting a host_info callback.



 * "type" == WEED_PLANT_HOST_INFO

'''Mandatory leaves''':

As of the current Weed and Filter API versions


WEED_LEAF_MALLOC_FUNC "weed_malloc_func"

WEED_LEAF_FREE_FUNC "weed_free_func"

WEED_LEAF_MEMSET_FUNC "weed_memset_func"

WEED_LEAF_MEMCPY_FUNC "weed_memcpy_func"


(Addded in API version 200):-
WEED_LEAF_CALLOC_FUNC "weed_calloc_func"

WEED_LEAF_REALLOC_FUNC "weed_realloc_func"

WEED_LEAF_MEMMOVE_FUNC "weed_memmove_func"

-----------

WEED_PLANT_NEW_FUNC "weed_plant_new_func"

WEED_PLANT_FREE_FUNC "weed_plant_free_func"

WEED_LEAF_GET_FUNC "weed_leaf_get_func"  :: WEED_SEED_FUNCPTR - pointer to function of type weed_leaf_get_f for the plugin to use

WEED_LEAF_SET_FUNC "weed_leaf_set_func"       :: etc...

WEED_LEAF_DELETE_FUNC "weed_leaf_delete_func"       :: etc...

WEED_LEAF_NUM_ELEMENTS_FUNC "weed_leaf_num_elements_func"

WEED_LEAF_ELEMENT_SIZE_FUNC "weed_leaf_element_size_func"

WEED_LEAF_SEED_TYPE_FUNC "weed_leaf_seed_type_func"

WEED_LEAF_GET_FLAGS_FUNC "weed_leaf_get_flags_func"

WEED_PLANT_LIST_LEAVES_FUNC "weed_plant_list_leaves_func"



 * "weed_api_version" : WEED_SEED_INT : weed api version exposed in host,

 * "filter_api_version" : WEED_SEED_INT : filter api version provided by host




'''Optional leaves''': [[BR]]

 * "plugin_info" : WEED_SEED_PLANTPTR : array of pointers to PLUGIN_INFO plants created from this template

 * "host_name"    : WEED_SEED_STRING : host name

 * "host_version" : WEED_SEED_STRING : host version

 * "flags"        : WEED_SEED_INT    : bitmap of host_info flags (see below)

 * "layout_schemes_supported" : WEED_SEED_STRING : an array of layout schemes that the host supports (see below, "layout_scheme")


The host may add any number of additional leaves, but it is recommended that it use keys prefixed "host_" to avoid
possible conflicts with future versions of the spec.



== PLANT TYPE PLUGIN_INFO ==

The plugin_info plant should be created by plugin in weed_setup() after receiving the host_info plant from weed_bootstrap()

The plugin may opt to call weed_plugin_info_init() (provided in libweed-plugin) instead,
passing weed_bootstrap as a parameter, in which case weed_bootstrap() will be run for it and the return value
used to create and return the plugin_info() plant.

The WEED_SETUP_START macro defined in weed-plugin-utils.h also calls weed_plugin_info_init().




The plugin should set up the leaves of that plant and then return it to the host from weed_setup().

Plugin info describes the filter classes which are available in the plugin.

After receiving the plant, the host may set all leaves in it IMMUTABLE / UNDELETABLE
and should not change any leaf values itself, except:

The plugin may add any nuber of additional private leaves with keys prefixed "plugin_"



 * "type" == WEED_PLANT_PLUGIN_INFO

'''Mandatory leaves''':[[BR]]

 * "filters"	  : WEED_SEED_PLANTPTR : array of pointers to the filters in the plugin

 * "version"	  : WEED_SEED_INT : plugin package version

 * "host_info"	  : WEED_SEED_PLANTPTR : pointer to the HOST_INFO plant created in weed_bootstrap() which contains information
                                         about the host.

'''Optional leaves''':[[BR]]


 * "package_name" : WEED_SEED_STRING : for wrapper filters, the name of the package which is wrapped

 * "maintainer"	  : WEED_SEED_STRING : maintainer of plugin package

 * "url"	  : WEED_SEED_STRING : URL of plugin package


The following may be set inside the weed_bootstrap() function from the values supplied by the plugin:

 * "min_weed_api_version"      : WEED_SEED_INT        :: min versions of the Weed API that the plugin supports

 * "max_weed_api_version"      : WEED_SEED_INT

 * "min_weed_filter_version"   : WEED_SEED_INT

 * "max_weed_filter_version"   " WEED_SEED_INT





== PLANT TYPE FILTER_CLASS ==

Plant type filter_class is used to describe all properties of a single
filter in a plugin. It is created by the plugin in weed_setup() and
then added to the plugin_info plant.

The plugin should not alter any values in the plant after weed_setup() but may add private leaves with keys prefixed "plugin_"

"type" == WEED_PLANT_FILTER_CLASS

'''Mandatory leaves''':[[BR]]

 * "name"         : WEED_SEED_STRING : the filter name; MUST be unique in the plugin, 
 * "author"       : WEED_SEED_STRING : the filter author(s) - DO NOT change this unless a new "version" of the plugin is made - instead add to the 
                      "extra_authors" leaf (see below)
 * "version"      : WEED_SEED_INT : filter version. Adding more parameters does not require a version update. However, removing parameters, changing 
   		    their order or type, adding or removing channel templates does require an update.
		    Prior versions of the filter MUST be left in plugin, as hosts may be using them.

'''Optional leaves''': [[BR]]

 * "flags"        : WEED_SEED_INT : bitmap of filter flags (see below)
 * "process_func" : WEED_SEED_FUNCPTR : pointer to the process_func()
 * "init_func"    : WEED_SEED_FUNCPTR : pointer to the init_func()
                    (can also be NULL)
 * "deinit_func"  : WEED_SEED_FUNCPTR : pointer to a the deinit_func()
                    (can also be NULL)
 * "in_channel_templates"    : WEED_SEED_PLANTPTR, list of 0 or more elements: array of inp channel templates, '''type''' of the referenced plant MUST be  WEED_PLANT_CHANNEL_TEMPLATE
 * "out_channel_templates"   : WEED_SEED_PLANTPTR, list of 0 or more elements : array of out channel templates, '''type''' of the referenced plant MUST be  WEED_PLANT_CHANNEL_TEMPLATE
 * "in_parameter_templates"  : WEED_SEED_PLANTPTR, list of 0 or more elements : array of in parameter templates, '''type''' of the referenced plant MUST be  WEED_PLANT_PARAMETER_TEMPLATE
 * "out_parameter_templates" : WEED_SEED_PLANTPTR, list of 0 or more elements : array of out parameter templates, '''type''' of the referenced plant MUST be  WEED_PLANT_PARAMETER_TEMPLATE.

 * "extra_authors": WEED_SEED_STRING : list of extra authors which can be altered without changing the plugin "version"
 * "description"  : WEED_SEED_STRING : filter description
 * "url"          : WEED_SEED_STRING : filter URL
 * "copyright"    : WEED_SEED_STRING : copyright details for filter
 * "license"      : WEED_SEED_STRING : license of filter
 * "target_fps"   : WEED_SEED_DOUBLE : plugin can inform the host of the target fps rate(s) for the
                                       host to run the plugin. Host should set "fps" for the
				       instance in this case.

 * "gui" : WEED_SEED_PLANTPTR : pointer to a plant
           type GUI [see below - GUI plants]. The host should not change this value, or any of the
           leaves inside it. The plugin may create it and set leaves
           in it weed_setup().

 * Every plugin can store internal data in leaves inside the
   filter_class  plant, and host MUST NOT change their values. Those internal leaves MUST have keys prefixed with "plugin_"

 * The host may add any additional keys required, but it is recommended that the keys be prefixed with "host_"


== PLANT TYPE FILTER_INSTANCE ==

Plant type filter_instance is created by the host, and used to hold all data that are related to
a single instance of the filter. Mandatory leaves MAY be set
IMMUTABLE by the host after weed_setup(), and should not be altered by the host. 
Optional leaves created by the host MAY be set IMMUTABLE.

The host examines a filter_class and prepares a filter_instance from
it. After this the host can pass the filter_instance into the filter's
init_func() [if the plugin has one] to prepare to use it.


"type" == WEED_PLANT_FILTER_INSTANCE

'''Mandatory leaves''':[[BR]]
 * "filter_class"   : WEED_SEED_PLANTPTR : Pointer to a filter_class plant
 that this filter instance is based on. MUST be one of the filters
 returned in the plugin's plugin_info plant.


The following are mandatory only if there are corresponding templates
in the filter class:

 * "in_channels"    : WEED_SEED_PLANTPTR, list of 0 or more elements : array of in channels, '''type''' of the referenced plants MUST be WEED_PLANT_CHANNEL

* "out_channels"   : WEED_SEED_PLANTPTR, list of 0 or more elements : array of out channels , '''type''' of the referenced plants MUST be WEED_PLANT_CHANNEL

* "in_parameters"  : WEED_SEED_PLANTPTR, list of 0 or more elements : array of in parameters, '''type''' of the referenced plants MUST be WEED_PLANT_PARAMETER

* "out_parameters" : WEED_SEED_PLANTPTR, list of 0 or more elements : array of out parameters, '''type''' of the referenced plants MUST be WEED_PLANT_PARAMETER





The following is mandatory if the plugin sets "target_fps" for either
filter_class or filter_instance:

 * "fps" : WEED_SEED_DOUBLE : the current target fps of the host running the instance
   (i.e frequency at which it attempts to call process_func() ).



 * Every plugin can store internal data in leaves inside this plant, and host MUST NOT change their values or make them
 READONLY for the plugin. Those internal leaves MUST have keys prefixed with "plugin_".

 * The host may add any additional keys required, but it is recommended that the keys be prefixed with "host_"





== PLANT TYPE CHANNEL_TEMPLATE ==

Plant type channel template is used as a description of a single channel (input or output) a filter can handle.
The plugin must not alter any leaves after weed_setup(), except it may add its own leaves with keys prefixed "plugin_",
which the host must not alter.


 * "type" == WEED_PLANT_CHANNEL_TEMPLATE

'''Mandatory leaves for all channels''': [[BR]]

 * "name" : WEED_SEED_STRING  : name of the channel, MUST be unique across all channels in the filter class

'''Mandatory leaves for channels with video''': [[BR]]

 * "palette_list" : WEED_SEED_INT   : the plugin sets this to an
 array of allowed palettes for the channel. Its order is plugin's
 preference for a palette. If this leaf is missing, the channel
 only supports audio.

'''Mandatory leaves for channels with audio''': [[BR]]

 See the weed AUDIO extension.

'''Optional leaves for all channel types''': [[BR]]

 * "flags" : WEED_SEED_INT : bitmap of channel_flags that plugin sets

 * "description"  : WEED_SEED_STRING : description of this channel

 * "max_repeats" : WEED_SEED_INT : maximum number of channels that
      the host can create from this template. A value of 0 indicates
      any number (limitless). If not present, "max_repeats" is assumed to be 1.
      If the channel_template is marked "optional", then the minimum number of this
      channel_template is 0, otherwise it is 1.

      If "max_repeats" is present, the number of repeats may be changed
      [reduced] by the host after init() and between processing calls without the need to re-initialise the
      plugin. In all other cases, a change in the number of channels requires
      the plugin to be re-initialised. 
      The number of channels may only be altered [reduced] by setting
      "disabled" to WEED_TRUE for one or more channels created from
      this template. This is allowed even if the template is not marked "optional" - though in the latter case the number 
      of non-disabled repeats must always be at least 1.

 * Every plugin can have its internal data stored in leaves inside this plant, and host MUST NOT change their values or make them
 READONLY for the plugin. Those internal leaves MUST have keys prefixed with "plugin_"

 * The host may add any additional keys required, but it is recommended that the keys be prefixed with "host_"



'''Optional leaves for channels with video''': [[BR]]

 * "width" : WEED_SEED_INT    : If set, frame width in pixels that a
   plugin can handle. If it is set, host is forbidden to set the width
   in channel instance to anything else. For YUV packed type palettes, the
   width is in macropixels (e.g for WEED_PALETTE_UYVY888, it is the
   width in UYVY macropixels). For planar YUV palettes, it is measured
   in the Y plane.

 * "height" : WEED_SEED_INT   : If set, frame height in pixels that a plugin can handle. If it is set, host is forbidden to set the height in channel instance to anything else 

 * "hstep" : WEED_SEED_INT : If set, the host must set the channel width to a multiple of this (in pixels). Should be avoided if possible for performance reasons.

 * "vstep" : WEED_SEED_INT : If set, the host must set the channel height to a multiple of this (in pixels). Should be avoided if possible for performance reasons.

 * "maxwidth" : WEED_SEED_INT : If set, the host must set the channel width <= maxwidth (in pixels)

 * "maxheight" : WEED_SEED_INT : If set, the host must set the channel height <= maxheight (in pixels)

 * "alignment_hint" : WEED_SEED_INT : If set, the host should attemp to align each plane in "pixel_data"
   	       	 	       	 to this many bytes boundary. In addition the rowstrides in each plane should be a multiple
				 of this value. If "hstep" is set then this value must be a multiple of "hstep".

 * "YUV_sampling"     : WEED_SEED_INT : Sampling type for YUV
                                        palettes, defined
                                        below. Default is mpeg if not set.

 * "YUV_clamping"     : WEED_SEED_INT : Clamping type for YUV
                                        palettes, defined below -
                                        Host should only use unclamped
                                        if plugin prefers it. Default
                                        is clamped, if not set.

 * "YUV_subspace"     : WEED_SEED_INT : Subspace (Y'CbCr digital, Y'UV
                                        analog or BT.709) type for YUV
					Effect plugins generally can ignore this.


'''Optional leaves for channels with audio''': [[BR]]

 See the weed AUDIO extension.






== PLANT TYPE CHANNEL ==

Plant type channel is used as a fixation of channel plants that the
host sets and plugin reads to know what it is getting. All leaves
SHOULD be set readonly for the plugin by the host.


Channels MUST be added in the order of channel_templates, bearing in
mind the template leaves "optional" and "max_repeats". After
initialisation, channels MUST NOT be added or removed without reinitialising the plugin.

 * "type" == WEED_PLANT_CHANNEL

'''Mandatory leaves for all channel plants''': [[BR]]
 * "template" : WEED_SEED_PLANTPTR : Pointer to a channel
 template plant this channel instance is based on.

* "width" : WEED_SEED_INT    : The chosen frame width in pixels. For
  YUV packed type palettes, the width is in macropixels (e.g for
  WEED_PALETTE_UYVY888, it is the width in UYVY macropixels). For
  planar YUV palettes, it is measured in the Y plane.

* "height" : WEED_SEED_INT   : The chosen height in pixels

* "current_palette" : WEED_SEED_INT: The chosen palette, which must be one of the palettes contained in "palette_list" of a channel template

* "pixel_data" : WEED_SEED_VOIDPTR    : array of n pointers to
 the image pixel data. Depending on the value of "current_palette",  there is 1 element for packed palettes, >1 elements for planar palettes

* "rowstrides" : WEED_SEED_INT     : array carrying the row width of EACH PLANE in bytes (include padding). Number of elements
 must match with number of elements in "pixel_data".

'''Mandatory leaves for channel plants with audio''': [[BR]]

 See the weed AUDIO extension.

'''Optional leaves for all channel plants''': [[BR]]
 * "disabled"     : WEED_SEED_BOOLEAN : the host MAY set this to
                    WEED_TRUE before calling init_func() if the corresponding channel template
                    has "optional" leaf set to true. Host MUST NOT change this without
                    reinitialising the instance. The one exception is if
		    the channel is based on a template which has
		    "max_repeats" set, in which case a channel from
		    that template may be disabled at any time between
		    processing calls.

 * "flags"        : channel flags set by host.


 * Every plugin can have its internal data stored in leaves inside this plant, and host MUST NOT change their values or make them
 READONLY for the plugin. Those internal leaves MUST have keys prefixed with "plugin_".

 * The host may add any additional keys required, but it is recommended that the keys be prefixed with "host_"



'''Optional leaves for channel plants with video''': [[BR]]

 * "offset" : WEED_SEED_INT : host can achieve multithreading by splitting destination frames into slices, calling the 
   	      		      process_func several times with different "offset"s and reduced height in the 
			      destination channel. Offset is the number of rows offset of "pixel_data" in the destination 
			      frame(s). Will only be used if the plugin sets the filter flag bit WEED_FILTER_HINT_MAY_THREAD.
			      See below - threading.

 * "pixel_aspect_ratio"   : WEED_SEED_DOUBLE : physical aspect ratio
                                               of the pixel of the image (pixel aspect ratio 
                                               different than 1.0
                                               means pixels are non-square) [set by host]


If the plugin sets any of these in the channel_template, and the host is using a YUV
"current_palette", host should try to match plugin preference where
possible, and process video accordingly:

 * "YUV_sampling"     : WEED_SEED_INT : Preferred sampling type for YUV
                                        palettes, host should try to
                                        match if plugin set it in template

 * "YUV_clamping"     : WEED_SEED_INT : Preferred clamping type for YUV
                                        palettes, host should try to
                                        match if plugin set it in template

 * "YUV_subspace"     : WEED_SEED_INT : Preferred YUV Subspace (see below)
                                        type for YUV palettes, host should try to
                                        match if plugin set it in template
					Generally not needed.


For RGB type channels:

 * "gamma_type" : WEED_SEED_INT :  [api 200 and above]
   		  		  	     set by the host to indicate the gamma transfer function of the RGB(A)
					     colour space in which the channel operates.
   		  		  	     If not set, it can be assumed to be WEED_GAMMA_SRGB.

					     * If the plugin set the filter flag bit WEED_FILTER_HINT_LINEAR_GAMMA,
					     then the host may set this to WEED_GAMMA_LINEAR.




'''Optional leaves for channel plants with audio''': [[BR]]

 See the weed AUDIO extension.






== PLANT TYPE PARAMETER_TEMPLATE ==

Plant type parameter_template is used as a description of a single
parameter (input or output) filter can handle. All leaves SHOULD be set readonly for the plugin by the host after
weed_setup(). Host should only change the "default" value to a valid
value for the parameter. The host should not change any other leaves.

'''Mandatory leaves''': [[BR]]

* "name" : WEED_SEED_STRING  : name of the parameter, MUST be unique across the in_parameters/out_parameters


* "default" :                default value(s) of the parameter : must contain at least one value of the correct seed_type
  	    		     unless the template has the WEED_PARAMETER_VARIABLE_SIZE flag set.
			     For out parameters, only the seed_type need be set, setting an actual value is optional.


 * "new_default" : 	     mmandatory only for in parameters which have the flag WEED_PARAMETER_VARIABLE_SIZE set. 
   		 	     Specifes the default value to be used by the host when adding new values to the parameter.


 * "hint" : WEED_SEED_INT : subdivides parameters into different kinds
 [see below]



'''Optional leaves''':[[BR]]
 * "flags"            : WEED_SEED_INT : bitmap of parameter flags

 * "description"      : WEED_SEED_STRING : parameter description

 * "interpolate_func" : TODO

 * "gui" : WEED_SEED_PLANTPTR : each parameter_template (for in_parameters) can have a
   	   		      "gui" leaf. This leaf points to a plant of type
 			      	    GUI. Within the GUI plant can be additional leaves to assist the host
 				    to display this particular parameter. The plugin can create it, and
				     set leaf values in it in weed_setup() and/or in init_func().
				     

 * Every plugin can have internal data stored in leaves inside this plant, and host MUST NOT change their values or make them
 READONLY for the plugin. Those internal leaves MUST have keys prefixed with "plugin_".

 * The host may add any additional keys required, but it is recommended that the keys be prefixed with "host_"



==== PARAMETER HINTS ====

The "hint" is a mandatory WEED_SEED_INT leaf of every parameter; the defined values are:

 * WEED_HINT_UNSPECIFIED
 * WEED_HINT_INTEGER
 * WEED_HINT_FLOAT
 * WEED_HINT_TEXT
 * WEED_HINT_SWITCH
 * WEED_HINT_COLOR

Depending on the "hint" parameter seed type additional leaves are:

 * WEED_HINT_UNSPECIFIED
This is a special "placeholder" value and requires no mandatory leaves.
Plugins should not create parameters with this hint.




 * WEED_HINT_INTEGER

"value" and "default" are constrained by min and max: min <= value <= max
The "default" leaf can only be of seed type WEED_SEED_INT. "default"
may have any number of elements.

 == mandatory ==

 * "min" : WEED_SEED_INT : minimal value of the parameter, MANDATORY for in parameters (optional for out parameters)

 * "max" : WEED_SEED_INT : maximal value of the parameter, MANDATORY for in parameters (optional for out parameters)


== optional ==

 * "wrap" : WEED_SEED_BOOLEAN : WEED_TRUE indicates that the "value" should wrap when going below min or above max, OPTIONAL

* "is_transition" : WEED_SEED_BOOLEAN : WEED_TRUE Indicates that this parameter is a transition,
  		    at min the effect is fully "off", showing ONLY the first in_channel as output,
		    at max it is fully "on", showing ONLY the second in_channel as output.
		    Only one parameter may have this leaf, it must be a single valued parameter of type integer or float,
		    and the plugin must have exactlty two mandatory input channels and mandatory output channel.
		    Otherwise this leaf is ignored.
		    Valid only for in parameters.





 * WEED_HINT_FLOAT

"value" and "default" are constrained by min and max: min <= value <= max

The "default" leaf can only be of seed type WEED_SEED_DOUBLE. "default" may have any number of elements.

== mandatory ==

 * "min" : WEED_SEED_DOUBLE : minimal value of the parameter, MANDATORY for in parameters (optional for out parameters)

 * "max" : WEED_SEED_DOUBLE : maximal value of the parameter, MANDATORY for in parameters (optional for out parameters)

== optional ==

* "wrap" : WEED_SEED_BOOLEAN : WEED_TRUE indicates that the "value" should be wrapped when going below min or above max

* "is_transition" : WEED_SEED_BOOLEAN : WEED_TRUE Indicates that this parameter is a transition,
  		    at min the effect is fully "off", showing ONLY the first in_channel as output,
		    at max it is fully "on", showing ONLY the second in_channel as output.
		    Only one parameter may have this leaf, it must be a single valued parameter of type integer or float,
		    and the plugin must have exactlty two mandatory input channels and mandatory output channel.
		    Otherwise this leaf is ignored.
		    Valid only for in parameters.




 * WEED_HINT_TEXT
A string type parameter. The "default" leaf can only be of seed type WEED_SEED_STRING.




 * WEED_HINT_SWITCH 
Indicates a boolean type parameter. The "default" leaf can only be of seed type WEED_SEED_BOOLEAN.


== optional ==

* "group" : WEED_SEED_INT : for all in_parameters with the same non-zero group: the "default" may only have a
 			    single value, and WEED_PARAMETER_VARIABLE_SIZE may not be set.

			    Only one parameter per non-zero group may have a "default" of WEED_TRUE. 
			    The host must ensure that only one parameter pernon-zero group has a "value" of WEED_TRUE. 




 * WEED_HINT_COLOR

Indicates a colour type parameter. Colors are represented as a list of elements of type WEED_SEED_DOUBLE or WEED_SEED_INT.
Depending on the seed_type of "default", the host knows the seed type of "value".


== Mandatory ==

* "min" : WEED_SEED_DOUBLE or WEED_SEED_INT; array of N elements: minimal value of the parameter,
  	  		      		     (optional for out parameters)

* "max" : WEED_SEED_DOUBLE or WEED_SEED_INT; array of N elements: maximal value of the parameter,
  	  		      		     (optional for out parameters)

* "colorspace" : WEED_SEED_INT : colorspace (see below), MANDATORY


== optional ==

 * "gamma_type" : WEED_SEED_INT : (optional) If the plugin set the flag WEED_FLAG_LINEAR_GAMMA, 
					     then this leaf can be set to WEED_GAMMA_SRGB to indicate the parameter values are in
					     the SRGB colourspace. Otherwise it is ignored by the host.


==== Number of elements in the leaves ====
For color parameters, the value size is 3 or 4, depending on the "colorspace". (3 for RGB, 4 for RGBA).

The "default" leaf must contain at least one RGB(A) value UNLESS the plugin sets the parameter template flag
WEED_PARAMETER_VARIABLE_SIZE; then the "default" may take any number of RGB(A) values or be absent;
if the number of RGB(A) values in "default" is 0 or absent, then "new_default" MUST contain exactly one RGB(A) value.

The number of RGB(A) values in "value" set by the host MUST match the number of RGB(A) values in
"default", UNLESS the plugin sets the parameter flag WEED_PARAMETER_VARIABLE_SIZE
then the "value" may take any number (0 or more) of RGB(A) values.


For color parameters:
The number of elements in "default" MUST always be a multiple of 3 or 4 (depending on the "colorspace" - 

For min and max, if the number of elements may be:

1: each R, G, B component uses the same min and/or max, and alpha may take any value
n: (where n is 3 or 4 depending on colorspace) each RGB or RGBA value will use the same set of values.
N: (where N is a multiple of 3 or 4, matching the number of elements in "default").

- The last option is not valid if the parameter has the flag bit WEED_PARAMETER_VARIABLE_SIZE set.


* It is recommended to use exactly one value for "default", unless WEED_PARAMETER_VARIABLE_SIZE is set.







== PLANT TYPE PARAMETER ==

Input parameter leaves should only be changed by the host, and
output parameter "value" only by the plugin. Parameters MUST match
one to one with parameter templates (same order, same number). For output 
parameters, the host should create the parameters from their templates, but not set the "value" leaf.



'''Mandatory leaves''': [[BR]]
 * "template" : WEED_SEED_PLANTPTR : pointer to the parameter_template used to create the parameter

 * "value" : seed type of the value MUST match the type of "default"
	     leaf of the parent_template. Lists/arrays can be implemented by
	     setting multiple elements in "default" (fixed list length), 
	     or by setting the parameter flag bit WEED_PARAMETER_VARIABLE_SIZE
	     (variable list length). 

	     For out parameters:
	      this leaf is set by the plugin, first in init_func() (where it MUST be set to its default),
	      then optionally in process_func().

 * "timecode" : WEED_SEED_INT64 : for out_parameters, whenever the "value" is set by the plugin in process_func()
                                  this leaf must also be set with the timecode which was passed as a parameter to
				  the function.


'''Optional leaves''':[[BR]]



 * "gamma_type" : WEED_SEED_INT : [api 200 and above]
   		  		  if the plugin set the WEED_FILTER_LINEAR_GAMMA flag, and the parameter hint is
				  WEED_HINT_COLOR, then the host will set this to indicate the gamma function of the RGB(A)
				  colour space in which the parameter operates.
   		  		  If not set, it can be assumed to be WEED_GAMMA_SRGB.

 * Every plugin can have its internal data stored in leaves inside this plant, and host MUST NOT change their values or make them
 READONLY for the plugin. Those internal leaves MUST have keys prefixed with "plugin_".

 * The host may add any additional keys required, but it is recommended that the keys be prefixed with "host_"






== PLANT_TYPE_GUI ==

This plant type has differing properties depending on whether it is
referenced from (i.e. contained in) filter_instance or from a parameter_template.

==== filter_class GUI ====
Plugin may set any of these leaves in weed_setup(). After that the plugin must not alter any leaves, except for private leaves
with keys prefixed "plugin_".


'''Optional leaves''': [[BR]]

 * "layout_scheme" : WEED_SEED_STRING : string defining the layout scheme selected for creating interface windows
                                        if the value is not equal to one of the elements of "layout_schemes_supported"
					set by the host in host_info, then the host is free to ignore this.

					Depending on the layout_scheme selected, there may be additional optional
					leaves describing the layout.

 * "icon"         : WEED_SEED_STRING : name of the associated icon (if
                                       any) in the icons subdirectory [see below - Plugin locations/format]

 * "hidden" : WEED_SEED_BOOLEAN : if set to WEED_TRUE, the filter  may be hidden from user menus by the host.
                                    (Intended for internal type filters.)


 * other optional leaves depend on the "layout_scheme" used by the plugin (if any).



 * Every plugin can have its internal data stored in leaves inside this plant, and host MUST NOT change their values or make them
 READONLY for the plugin. Those internal leaves MUST have keys prefixed with "plugin_".

 * The host may add any additional keys required, but it is recommended that the keys be prefixed with "host_"



==== parameter_template GUI ====
Plugin may set and change these leaves in weed_setup() and/or in init_func(). At other times the plugin must not
alter any of the leaves, excet for those with keys prefixed "plugin_"

All of these leaves indicate optional functionality for the
host. For example, the plugin should not rely on setting "maxchars" to
ensure a string is constrained to certain length, neither should it
rely on setting "copy_value_to" to force the host to set indentical
"values" for two parameters.


'''Optional leaves''': [[BR]]

* "label" : WEED_SEED_STRING : label for display

 * "use_mnemonic" : WEED_SEED_BOOLEAN : WEED_TRUE indicates whether "label" uses
    underscore as mnemonic

 * "choices" : WEED_SEED_STRING : n values for a choice: only valid
   for INT parameters, the "value" element(s) indicate the selected
   element(s);
   The actual value of "max" is ignored,
   "max" is assumed to be equal to the number of elements in "choices".
   "min" must be 0 or -1.
   For the "value", 0 indicates first element in "choices". A value of -1 (if
   allowed by "min") indicates "no selection". For non-INT parameters, this
   leaf will be ignored. If "choices" is present, then "wrap" and
   "step_size" may be ignored by the host.

 * "decimals" : WEED_SEED_INT : number of decimals for a FLOAT or
   COLOR (FLOAT) hint. For other hints this will be ignored.

 * "step_size" : seed type matches type of "default" : step value for
   INTEGER, FLOAT and COLOR type parameters : used for spin buttons, etc.

 * "maxchars" : WEED_SEED_INT : max display length in (utf-8) chars for a
   STRING hint. For other hints, this will be ignored. A value < 1 should
   also be ignored.

 * "hidden" : WEED_SEED_BOOLEAN : if set to WEED_TRUE, the parameter
   may be hidden by the host.

 * "copy_value_to" : WEED_SEED_INT : index (0 means first parameter, 1
   means second, etc.)
   of another in_parameter : if the "value" of this parameter is changed, then the
   "value" of the parameter pointed to may be
   set to the same value. Both parameters MUST have the same HINT and
   number of elements in "default", otherwise this will be ignored. Only
   valid for in_parameters. If more than one parameter points to the
   same in_parameter, the behaviour is undefined. NOTE: this is not
   strictly GUI functionality. Even GUI-less hosts might want to implement
   this ! This can be disabled by setting it to a value < 0, or by
   setting it to point to itself.

 * Every plugin can have its internal data stored in leaves inside this plant, and host MUST NOT change their values or make them
 READONLY for the plugin. Those internal leaves MUST have keys prefixed with "plugin_".

 * The host may add any additional keys required, but it is recommended that the keys be prefixed with "host_"





=== WEED_SETUP ===========

The full details of the plugin / host initialisation are described here.

The host should first load the plugin and then at some later point mat call the weed_setup() function in it.


e.g:

....
weed_setup_f setup_fn = (weed_setup_f)dlsym(handle, "weed_setup");

weed_plant_t *plugin_info = (*setup_fn)(weed_bootstrap); // using weed_bootstrap from libweed-utils



At the start of weed_setup(), the plugin must call the weed_bootstrap function, passing in a pointer to receive default_getter_f,
and the lowest and highest versions of WEED_API_VERSION and WEED_FILTER_API_VERSION it supports, the returned value will be a
host_info plant created by the host, e.g.:


  weed_default_getter_f weed_default_getf;
  weed_plant_t *host_info = (*weed_boot)(&weed_default_getf, weed_api_min_version, weed_api_max_version,
                                         weed_filter_api_min_version, weed_filter_api_max_version);




Control now returns to the host in its weed_bootstrap function.


weed_plant_t *weed_bootstrap(weed_default_getter_f *value,
			     int32_t plugin_min_weed_api_version,
			     int32_t plugin_max_weed_api_version,
			     int32_t plugin_min_filter_api_version,
			     int32_t plugin_max_filter_api_version);



The host now has a chance to review which weed and filter api versions the plugin supports and to adjust the functionality
offered to the plugin accordingly. It is for this reason that the host does not pass the host_info plant directly to the plugin
when calling weed_setup.

If the host does not support the plugin's api versions, it should return NULL from weed_bootstrap.
In this case the plugin should return NULL from the weed_setup() function, so that the host can unload it.


Otherwise, the host will set value to point to a default getter function in the host of the form:

{{{
   weed_error_t default_getter(weed_plant_t *plant, const char *key, void *value)
}}}

and return a configured HOST_INFO plant.

value should be a pointer to a variable suitable for the value requested. The plugin (or library) should first fetch the Weed API
version (key = WEED_LEAF_WEED_API_VERSION or WEED_LEAF_WEED_ABI_VERSION, type = int32_t)
then depending on the value of that it can retrieve the core Weed functions for the API version, or return NULL if it's an
unsupported version.

After this, the plugin or library  may retrieve the filter API version (key = WEED_LEAF_FILTER_API_VERSION, seed_type =
WEED_SEED_INT, using the normal Weed functions, and either choose to continue or else return NULL.




If using libweed-utils, the provided weed_bootstrap will automatically check versions and set the plugin API accordingly.
Its weed_bootstrap also provides a callback to the host so that the host can adjust the configured host_info.


example:

  if ((*weed_default_getp)(host_info, WEED_LEAF_GET_FUNC, (weed_funcptr_t *)&weed_leaf_get) != WEED_SUCCESS) return NULL;


[The default getter should use only standard memory functions, so that the plugin can 
bootstrap its memory functions (weed_malloc, weed_free, weed_memcpy etc.).
There is a version implemented in the weed_utils library which the host can use.]


Normally a plugin would use a utility library which would take care of
calling the bootstrap function and setting up its API functions.

The plugin can also retrieve the "weed_api_version" and "filter_api_version" leaves to discover the API versions the host
assigned it. 

The weed_setup() function in the plugin will return a PLUGIN_INFO plant that
specifies what is the content of this plugin - which filter classes it has, who is the maintainer, etc.

The Plugin implements weed_setup() in following way: the PLUGIN INFO plant is first created by using weed_plant_new(). 
The individual filters are then created and added to the "filters" leaf in the PLUGIN INFO plant.
If no filters can be created (because of memory or other problems or version mismatches), the function should return NULL.

The returned plant MUST have '''type''' WEED_PLANT_PLUGIN_INFO.



To recap:

1) host calls weed_init() once with an API version to get its weed functions

2) host dlopens a plugin, then calls weed_setup() in the plugin, passing in a ponter to the bootstrap_fn

3) plugin calls the bootstrap_fn in the host, passing ptr to default_getter, and and min and max api versions it can support.
   The maximum versions should be set to the current version at the time the plugin is created.
   If the plugin is later updated, the max versions can be increased accordingly.

4) host selects weed and filter api versions it will provide, ensuring these are higher than the
   lowest version that the plugin supports (because it cannot know what features may be added in the future...),
   and if higher than the maximum, that the versions are compatible.
   It also sets default_getter function for plugin.
   If the host cannot support the API versions of the plugin, then it should return NULL.

   The idea is that if a plugin relies on features that the host cannot support yet, then it should not be loaded.
   In addition, if a future change breaks compatibility with the plugin, then the host has the option of using a lower API
   version so that the plugin can still run.

   Thus, it is advisable for a plugin author to set the minimum values as low as possible, and the maximum values to the current
   versions. If features were added between the highest and lowest versions, then the plugin can check the host API versions to
   discover whether or not the host supports them.

   The maximum values should be set manually and should not be set from the WEED_API_VERSION or FILTER_API_VERSION symbols,
   as these may increase each time the plugin is compiled. It may be that a future API version breaks compatibility and
   the host will assume that the plugin can handle the changes.



5) after returning from weed_bootstrap, the plugin should check the API version returned by the host,
   and use the default_getter function to bootstrap itself and then fetch the appropriate functions for that API version.




6) plugin then sets up its plugin_info plant and returns it as the value from weed_setup()



This may seem complex, but it provides several advantages:

- each API version can have its own set of core functions

- host and plugin can negotiate the plugin API version and select the highest version which they both 
  support

- function overloading can be done. The host and plugin can have functions with the same name
  but which actually resolve to different functions (for example, host and plugin both use
  weed_leaf_set, but the the host can set this to point to a different version of the function, for example to debug a particular
  plugin.

- the host can have access to functions which the plugin cannot, for example, only the host 
  can call weed_leaf_delete, (unlocked) weed_plant_free and weed_leaf_set_flags





==== Filter errors ====

Defined in weed-effects.h

 *  WEED_SUCCESS
    (This is a standard Weed error code defined in weed.h)
    The plugin should return this if it encountered no errors in the function. a.k.a WEED_NO_ERROR.

 *  WEED_ERROR_PLUGIN_INVALID    [[BR]]
    May be returned from any plugin function.
    The plugin encountered a fatal error and should no longer be used. The host should call deinit_func() for any active instances
    and then the desetup function for the plugin, and refrain from using it further.

 *  WEED_ERROR_FILTER_INVALID    [[BR]]
    May be returned from init_func() or process_func(). Only applies to plugins which create multiple filters (e.g. wrapper
    plugins.) The filter_class from which this instance was created from is no longer valid.
    The host should call deinit_func() for any active instances created from the corresponding filter class, and refrain from
    using them further. The host may still use other, valid filters in the plugin.

 *  WEED_ERROR_TOO_MANY_INSTANCES   [[BR]]
    If a plugin allows only a limited number of filter instances, it may return this from the init_func().
    The host must not call any further plugin functions for the instance.

*   WEED_ERROR_MEMORY_ALLOCATION
    (This is a standard Weed error code defined in weed.h)
    The plugin may return this from the init_func() or process_func(). The plugin iself should call deinit_func() on the instance
    and free any internal memory structures. The host must not call process_func() or deinit_func() for the instance,
    but may retry the init_func() with the same or a new instance.

 *  WEED_ERROR_REINIT_NEEDED
    Returned from process_func(). The plugin enountered an error condition and requires that the host call deinit_func() and
    init_func() again before retrying the process_func(). If the plugin returns this error again after reiniting by the host,
    then there is a fault either in the plugin or in the host.
    This should only be used for emergency situations; generally the channel_template or parameter_template flags should be
    sufficient.




Deprecated (do not use in newly written code):
 *  WEED_ERROR_HARDWARE    [[BR]]
    there was a hardware error using the filter; returned
    from init_func() or from process_func(). If returned from
    process_func(), the filter should be deinited/reinited. (deprecated)

 *  WEED_ERROR_INIT_ERROR    [[BR]]
    other unspecified error during initialisation (deprecated)






==== host plugin flags ====

 * WEED_HOST_SUPPORTS_LINEAR_GAMMA  1  [BR]] (api 200 and above)
   Denotes that the host will pay attention to the WEED_FILTER_HINT_LINEAR_GAMMA filter flag.



==== Filter_class flags ====

 *  WEED_FILTER_NON_REALTIME  1  [[BR]]
    non-realtime filter: the filter is too slow to use in realtime processing.
    The exact definition of what is realtime and what is not is left to the plugin author to decide.


 *  WEED_FILTER_IS_CONVERTER  2  [[BR]]
    This flag bit should be set if the plugin does not alter the image
    pixels except for resizing or palette conversion between in
    channel and out channel(s). It should only be set for the
    following types of plugins: plugins which only resize the in frame
    to out frame(s); plugins which only convert the palette from in
    frame to out frame(s), plugins which simply duplicate the in frame
    to out frame(s), and for plugins which handle only audio, where the
    plugin only alters the audio volume [see the Weed Audio
    Extension].

    It is used to assist with categorisation of the
    plugin type. To be useful, such filters may also want to use the
    *_CAN_VARY channel flags below.

 * WEED_FILTER_HINT_IS_STATELESS  4  [[BR]]
   This is optional, if the filter is stateless (i.e. not dependant on
   past calls to process_func() ) then this this flag
   bit can be set. Used mainly for compatibility with other plugin architectures.

 * WEED_FILTER_HINT_LINEAR_GAMMA  8  [BR]] (api 200 +)
   This is a hint to the host that the plugin prefers to use R, G, B values in linear gamma space.
   (see note below about colour spaces)

 * WEED_FILTER_HINT_PROCESS_LAST
   This is a hint to the host that the filter should be run AFTER all other filters have performed their processing.
   Examples would be a video filter that overlays subtitles on the finished frame,
   or an audio filter that mixes the final output of several input audio channels. If there are several filters like this in
   the processing chain, then the host should decide the order to run them in.

*  WEED_FILTER_HINT_MAY_THREAD
   If a video plugin (TODO - implement for audio ) operates in such a manner that its output may be subdivided vertically,
   then it may set this hint. Ignored for filters which have no out_channels.
   See note below about threading.

   

==== Channel template flags ====

  * WEED_CHANNEL_OPTIONAL
    channel that can be left out at initialization time.
    the host decides not to use the channel, it must set "disabled" to
    WEED_TRUE for the channel. The host must reinit
    the instance if a channel is enabled or disabled after init_func().

 *  WEED_CHANNEL_REINIT_ON_SIZE_CHANGE   [[BR]]
    host must reinit the plugin before calling process_func() if the
    channel size (height or width in (macro)pixels) is changed.

 *  WEED_CHANNEL_REINIT_ON_PALETTE_CHANGE   [[BR]]
    host must reinit the plugin before calling process_func() if the channel palette is changed

 *  WEED_CHANNEL_CAN_DO_INPLACE    [[BR]]
    If this flag bit is set, the filter can do inplace operations.
    Hosts can select this mode by setting "pixel_data" of this out channel
    equal to the "pixel_data" of the corresponding (same number; not counting "disabled" channels) 
    in channel. The flag bit is only valid for OUT channels. 

 *  WEED_CHANNEL_SIZE_CAN_VARY    [[BR]]
    All channels are assumed to have the same (macro) pixel size (width and height, but not necessarily rowstrides)
    as the first non-disabled in_channel (or first non-disabled
    out_channel for filters that have no in channels). If this flag
    bit is set, then the host can set this channel to a different (macro) pixel size.
    For fixed size channels, it is not necessary to set this.
    Plugins should avoid resizing internally as much as possible, unless they have a "high-performance" resize routine.
    Otherwise resizing should be left to the host.

 *  WEED_CHANNEL_PALETTE_CAN_VARY    [[BR]]
    In Weed, all channels are assumed to have the same "current_palette"
    as the first non-disabled in_channel (or first non-disabled
    out_channel for filters that have no in channels). If this flag
    bit is set, then the host can set this channel to a different
    allowed palette. Plugins should not perform palette conversions
    unless it is unavoidable, and they have a "high-performance" palette
    conversion routine. Otherwise palette conversion should be left to
    the host.

 *  WEED_CHANNEL_REINIT_ON_ROWSTRIDES_CHANGE    [[BR]]
    host must reinit the plugin before calling process_func() if the
    any of the rowstrides are changed. Note that	 
    changing the palette can sometimes affect the rowstrides. [API 130 and higher].

    This is useful; for example, if the input palette were to change from RGB to RGBA, then the
    even though the width in pixels might be the same, the rowstrides value will change (e.g from
    3 * width to 4 * width. So if a plugin is sensitive to frame size changes it may want to set
    WEED_CHANNEL_REININT_ON_SIZE_CHANGE | WEED_CHANNEL_REINIT_ON_ROWSTRIDES_CHANGE.

    In the above example, the plugin could set the hints REINIT_ON_SIZE_CHANGE | REINIT_ON_PALETTE_CHANGE instead.
    However, if the palette were changed from RGB24 to BGR24 for example, it may be possible for the plugin to continue
    processing, since in this case the frame size (rowstride * height) would remain the same.


Flag bits >=30 are reserved for custom flags.




==== Parameter template flags ====

 * WEED_PARAMETER_REINIT_ON_VALUE_CHANGE  1  [[BR]]
   host must reinit the plugin if the parameter "value" is
   changed. This is to allow the plugin to readjust its internal state as well as to alter the "gui" settings
   for the parameters and for the instance.
   The host must emsure the plugin has write access to the "gui" plants during the init_func().
   Only valid for in parameters.


 * WEED_PARAMETER_VARIABLE_SIZE  2  [[BR]]
   plugin can set this to inform the host that the number of values in the parameter "value" leaf can vary.
   If not set, then the number of values in "value" is fixed; it must always match the number of values in "default".

   If this is set, then the plugin may only use one element in each of "min" and "max" for the parameter,
   (except for COLOR parameters which may use 3 or 4 depending on the "colorspace".)

   Note also that 0 is a valid number of elements. [0 elements means the leaf exists but has no value]

   If this is set for an in parameter, the plugin MUST also set the "new_default" leaf for the parameter.

   This flag is ASSUMED for out parameters.


 * WEED_PARAMETER_VALUE_PER_CHANNEL  4  [[BR]] - 
   This flag bit indicates that each value in the parameter "value" corresponds to one input channel.
   The order of channels and values is the same.

   If a channel template has "max_repeats" set to other than 1, then WEED_PARAMETER_VARIABLE_SIZE
   is ASSUMED to be set for the parameter, and thus the "new_default" leaf MUST also be set.
   It is good practice to set the flag bit anyway.

   Valid for in parameters only.


Flag bits >= 30 are reserved for custom flags.



== WEED FLAGS AND TYPES ==


==== Plant types ====

  * WEED_PLANT_HOST_INFO          255

  * WEED_PLANT_PLUGIN_INFO        1

  * WEED_PLANT_FILTER_CLASS       2

  * WEED_PLANT_FILTER_INSTANCE    3

  * WEED_PLANT_CHANNEL_TEMPLATE   4

  * WEED_PLANT_PARAMETER_TEMPLATE 5

  * WEED_PLANT_CHANNEL            6

  * WEED_PLANT_PARAMETER          7

  * WEED_PLANT_GUI                8



==== Weed parameter hints ====

 * WEED_HINT_UNSPECIFIED  0
   Parameter is of an unknown type. Plugins should never use this
   directly, it is intended only for wrapper plugins which may need to
   convert unknown parameter types. These parameter types may or may not
   have "min" and "max". They will have at least "name" and "default" leaves.

 * WEED_HINT_INTEGER  1

 * WEED_HINT_FLOAT  2

 * WEED_HINT_TEXT  3

 * WEED_HINT_SWITCH  4

 * WEED_HINT_COLOR  5

Parameter hints >= 1024 are reserved for custom parameters.



==== Weed colorspaces ====
 // Used for WEED_HINT_COLOR parameters.

 * WEED_COLORSPACE_RGB  1

 * WEED_COLORSPACE_RGBA  2

Colorspaces >= 1024 are reserved for custom color spaces.







==== Weed palette types ====

Some palettes have aliases; these are shown on the same line.

'''Special Palettes'''
Palette number 0
{{{
WEED_PALETTE_END
may be used in setup_func() in an int *palettes, denotes the end of the palette list; "palette_list" property
}}}

'''RGB Palettes'''
Palette numbers >0 and <512
{{{
WEED_PALETTE_RGB888         WEED_PALETTE_RGB24   1  :: packed, 8 bits per colour channel, 24 bits per pixel, RGB
WEED_PALETTE_BGR888         WEED_PALETTE_BGR24   2  :: packed, 8 bits per colour channel, 24 bits per pixel, BGR
WEED_PALETTE_RGBA8888       WEED_PALETTE_RGBA32  3  :: packed, 8 bits per colour channel, 32 bits per pixel, RGBA
WEED_PALETTE_BGRA8888       WEED_PALETTE_BGRA32  7  :: packed, 8 bits per colour channel, 32 bits per pixel, BGRA
WEED_PALETTE_ARGB8888       WEED_PALETTE_ARGB32  4  :: packed, 8 bits per colour channel, 32 bits per pixel, ARGB
WEED_PALETTE_RGBFLOAT                            5  :: packed, 32 bit float per channel RGB (range is 0. to 1.)
WEED_PALETTE_RGBAFLOAT                           6  :: packed, 32 bit float per channel RGBA (range is 0. to 1.)

}}}
'''YUV Palettes'''
Palette numbers >=512 and <1024

Ranges are 16-235 for Y, 16 - 240 for U and V, unless
WEED_YUV_CLAMPING_UNCLAMPED is set in "YUV_clamping" for
channel/channel_template (in which case the range is 0 - 255 for each component).

Subspace may be any YUV subspace, unless "YUV_subspace" is set for channel/channel_template.

All channels are assumed to be 8 bit.

{{{
WEED_PALETTE_YUV422P           WEED_PALETTE_YV16    513
[Official name 'YV16', 8 bit Y plane followed by 8
   bit 2x1 subsampled U and V planes. Planar.]


WEED_PALETTE_YUV420P           WEED_PALETTE_YV12    514
[8 bit Y plane followed by 8 bit 2x2 subsampled U and V planes. Planar.
   (Official name YV12)]

WEED_PALETTE_YVU420P           WEED_PALETTE_I420         WEED_PALETTE_IYUV   515
[Same as YUV420P , but U and V are swapped. Planar.
      (Official name IYUV)]

WEED_PALETTE_YUV444P   516
[unofficial. 8 bit Y plane followed by 8 bit U and V planes, no
   subsampling. Planar.]

WEED_PALETTE_YUVA4444P   517
[Unofficial, like YUV444P but with Alpha. Planar.]

WEED_PALETTE_UYVY8888         WEED_PALETTE_UYVY     519
[YUV 4:2:2 (Y sample at every pixel, U and V sampled at every second
   pixel horizontally on each line). A macropixel contains 2 pixels in 1
   u_int32. Packed. If the "YUV_subspace" is set to bt709, this
   becomes HDYC.]

WEED_PALETTE_YUYV8888         WEED_PALETTE_YUYV          WEED_PALETTE_YUY2     518
[Like UYVY but with different component ordering within the
   u_int32 macropixel. Packed. Also known as YUY2]

WEED_PALETTE_YUV411                   WEED_PALETTE_IYU1        520
[IEEE 1394 Digital Camera 1.04 spec. Is packed YUV format
with a 6 pixel macroblock structure containing 4 pixels.
Ordering is U2 Y0 Y1 V2 Y2 Y3. Uses same bandwith as YUV420P
Used for SMPTE DV NTSC / DVCPRO PAL (???)]
Also known as IYU1.

}}}

WEED_PALETTE_YUV888                   WEED_PALETTE_IYU2      521
Packed YUV palette, no subsampling. Also known as IYU2

WEED_PALETTE_YUVA8888                                        522
Packed YUV palette with alpha channel. No subsampling.


'''Alpha Palettes'''
Palette numbers >=1024 and <2048

Alpha palettes are generally used as mask/transparency channels but may be used to store any position dependant data.

{{{
WEED_PALETTE_A1       1025
WEED_PALETTE_A8       1026
WEED_PALETTE_AFLOAT   1027
}}}

The range for AFLOAT is 0.0 (fully transparent) to 1.0 (fully opaque) for transparency. 
For other data a different range may be used.


Palette numbers >=2048 are reserved for custom palettes.


==== Gamma types (api 200 and above) ====

 * WEED_GAMMA_UNKNOWN 0

 * WEED_GAMMA_SRGB 1

 * WEED_GAMMA_LINEAR 2

Gamma types >=1024 are reserved for custom color gamma types.


==== YUV sampling types ====

Where chroma subsampling is used, chroma values are assumed to be centered between luma samples, unless
specified otherwise.

 * WEED_YUV_SAMPLING_DEFAULT  0  : Default subsampling.

 * WEED_YUV_SAMPLING_JPEG  0   : Chroma is sampled at half the horizontal
   and half the vertical frequency. (YUV 4:2:0). Chroma samples are
   alternated horizontally between luma samples (like yuyv-yuyv)

 * WEED_YUV_SAMPLING_MPEG  1  : Same as JPEG, but Chroma samples are
   horizontally aligned. There is notion of fields. Note: only mpeg2 uses this, mpeg1 uses JPEG sampling.
   (YUV 4:2:0 only) (like yuvy-yuvy) (left sampling)

 * WEED_YUV_SAMPLING_DVPAL  2  : Subsampling per field, chroma samples
   are located above and below luma samples, and CB and CR samples are located on alternate lines (YUV 4:2:0) 

 * WEED_YUV_SAMPLING_DVNTSC  3  : Chroma is sampled at a reduced
   horizontal frequency but is aligned horizontally with luma samples
   (YUV 4:2:2 / YUV 4:1:1) [similar to mpeg, but vertically aligned] (top left)

Sampling types >= 1024 are reserved for custom samplings.



==== YUV clamping ====

 * WEED_YUV_CLAMPING_CLAMPED  0  :: the default if not present (clamped to 16-235,
   16-240, 16-240)                                                 

 * WEED_YUV_CLAMPING_UNCLAMPED  1  :: Y, U and V are unclamped (0 - 255 range
   for each) [used in jpeg for example]

clamping types >= 512 are reserved for custom clampings.



==== YUV subspace ====

 * WEED_YUV_SUBSPACE_YUV  0   :: Any YUV colourspace may be used, with Y representing the luma 
   channel, and U and V as colour offsets. Optional, since this is the default if not specified.

 * WEED_YUV_SUBSPACE_YCBCR   1  :: Standard YUV (Y'CbCr 601) using conversion
   factors (Kr=0.299, Kb=0.114, UV offset 128). The plugin should specify this if for example 
   it sends to or receives from external sources.

 * WEED_YUV_SUBSPACE_BT709   2  :: BT.709 high definition TV which uses different
   conversion factors than Y'CbCr digital/ananlog (Kr=0.2125, Kb=0.0721, UV offset 128)

subspace types >= 512 are reserved for custom subspaces.




== NOTE ABOUT COLOUR SPACES ==
Channels with alpha:
Alpha is always POST MULTIPLIED in Weed. If you need or produce pre-multiplied alpha, you need to convert it.


Gamma types:
As of API version 200, Weed effect plugins may choose to operate in the LINEAR (i.e. perceptual) gamma space.
This means that for RGB type palettes, the component values (R, G, B) represent the values which are displayed on the monitor.

For example, since the human eye perceives darker values more strongly than lighter values, a mid-grey in this colour space has
an (R, G, B) value of (55, 55, 55). This colour space is used since it is much better for calculating visual brightness (luma)
values, and for mixing (adding) and multiplying colour values perceptually. Thus all colour "pixel_data" values for RGB(A) will
be supplied by the host or generated by the plugin using this colour space ('transfer function' to be more precise).

In addition to the "pixel_data" values, the R, G, B VALUEs of any WEED_HINT_COLOR type parameters will be maintained to this
colour space by the host, although they mau be displayed differently to the user.

So for example if the user entered (127, 127, 127) for a colour value in the GUI, then the plugin would
receive the values (55, 55, 55). When creating the parameter templates, the DEFAULT and NEW_DEFAULT values should also be
in linear gamma. (For float types, the equivalent is 0.5 ~= 0.181818...).

If the host supports this, it will set the WEED_HOST_SUPPORTS_LINEAR_GAMMA bit in the HOST_INFO "flags".

The plugin may then set the flag WEED_FILTER_HINT_LINEAR_GAMMA in filter flags for any filter class.

Subsequently, the host will then set the "gamma_type" leaves for any RGB type CHANNEL instances
and any colour type PARAMETER instances to WEED_GAMMA_LINEAR.

The plugin can request this behaviour be overridden for individual parameters (in or out) by setting the
PARAMETER_TEMPLATE's "gamma_type" leaf to WEED_GAMMA_SRGB.

The host should then leave the VALUEs in the sRGB space and set "gamma_type" to WEED_GAMMA_SRGB for the PARAMETER instance.
Note this applies only to paramters; individual channels cannot be overridden in this manner.

N.B. This mode may be much better for plugins that want to mix / overlay channels or colour values,
or use perceptual brightness values without any reference to absolute colour values. 










== OUTLINE WEED PROCESS FLOW OVERVIEW ==

 * Host calls weed_init(), passing in the weed api version it wants to use. If successful, the function sets the core Weed functions
   for the host.

 *  Host loads plugin (using dlopen)

 *  Host calls the weed_setup() function in the plugin, passing in a pointer to the bootstrap function (normally this would be
    weed_bootstrap in the weed-utils library.

 *  plugin calls the bootstrap function, passing an address to return the default getter function, as well as the minimum and
    maximum weed and filter api versions the plugin supports. The library checks weed and filter api_versions supported by
    the plugin. If either host version is less then the plugin minumin version the plugin
    cannot be loaded. If one or both of the values are greater than the maximum, the library checks for compatibility.
    If the host version and plugin version are incompatible, the plugin cannot be loaded so NULL is returned. Otherwise it is OK
    to proceed. The weed_boostrap function will create a HOST_INFO plant and set leaves with the host api versions,
    pointers to the functions the plugin should use, and return it to the plugin, as well as setting the default getter function,
    Optionally, the library will call a callback function in the host before returning the PLUGIN_INFO, so that the host can
    check, alter or add leaves before it is returned to the plugin.


*  if the HOST_INFO is NULL, the plugin MUST return NULL from its weed_setup() function. Otherwise the plugin uses the
   default_getter to get the leaves of the HOST_INFO plant until it has enough functions defined to use the normal
   Weed get function for its weed api version. Then it uses this to get the remaining leaves. Once this is done it creates a
   PLUGIN_INFO plant. All this would normally be done in the weed-plugin-utils library, weed_plugin_info_init().




All of this is simplified by the Weed utility libraries. The host simply calls weed_setup() in the plugin, passing in
weed_bootstrap as the only parameter, and receives back a PLUGIN_INFO.


On the plugin side, a simple macro taking 2 parameters, the maximum weed and filter APIs supported, may be used to call the
bootstrap function and initialise the PLUGIN_INFO, returning NULL to the host if it is NULL. The minimum API versions are assumed
to be equal to the maximum versions. A different variation of the macro can be used which takes an additional 2 parameters if the
plugin author wants to specify lower minimum values.





When host wants to use the plugin,

 * Host creates a FILTER_INSTANCE: Host examines the in_channel and out_channel plants, and sets the "disabled" flag for any optional channels it does not wish to use. It also checks "palette_list", selects a palette it would like to start using on that channel and sets the chosen value in the "current_palette" leaf. It also sets the sizes ("width" and "height" leaves) if the plugin left them as zero. All input parameters have to have values set at this point. This means host now has a plant that it will instantiate.

 * Host calls init_func() [if it exists] from the filter info plant, passing a pointer to a FILTER_INSTANCE it would like to instantiate.

* Plugin now knows the channel sizes, palettes and which channels are in use. The plugin may now weed_malloc() internal data.

 * Host may now change parameter values (respecting "max" and "min" leaves) and it after that it may call process_func() in the plugin, passing in the initialised FILTER_INSTANCE. 
 * When the host has finished with the FILTER_INSTANCE, or if it needs
   to re-initialise it, the host must call deinit_func() in the plugin
 [if the plugin has one], passing in a pointer to the FILTER_INSTANCE. The plugin MUST now weed_free() any internally allocated data.

 * Host can now weed_plant_free() the FILTER_INSTANCE, or it can reuse the FILTER_INSTANCE by calling init_func() once more.




== Plugin locations ==

The list of directories to be searched can be set in the environment
variable WEED_PLUGIN_PATH; directories in WEED_PLUGIN_PATH should be separated by
colons (:) the indicated directory and ONE LEVEL OF SUDIRECTORIES
should be searched for each entry.

shared Icons may be placed in a /icons subdirectory., and at a plugin author's discretion, a package may install icons in icons/<packagename> 

Readonly data files  may be placed in a /data subdirectory for shared data, and during installation a package may choose to install
readonly files in data/<packagename> directory, where <packagename> is the well known name of the package, usually, but not always equivalent to the .so name of the plugin supplying the filter class(es).






==== Plugin threading ====

Filter_class flag WEED_FILTER_HINT_MAY_THREAD

   The plugin can set this if it can still produce its output when the destination frame is subdivided into non-overlapping,
   contiguous horizontal areas each with a reduced height.

   In this case, the process_func() may be called several times with the same timecode, and with a partial copy of the instance for
   each thread.

   In the thread instances,
   every non-disabled out channel will have an extra "offset" leaf, and the height leaf will now contain 2 values,
   height[0] is the reduced height height[1] is the real height.

   The "offset" leaf shall contain the offset in rows of the start of the thread's block from the start of the out channel
   pixel_data.

   The plugin MUST only write to the destination rows between offset and offset + height[0] - 1.

   When allocating the slices, the host MUST take into consideration any "vstep" value set by the host in the out channel template.
   and ensure that each slice is a multiple of this value.

   Each thread MUST ONLY write to the out channels in the rows from offset to offset + height[0].

   The plugin may read from any area of the input channel(s) pixel_data, but be aware that if
   the plugin is running "inplace" then the values read from the in channels may or may not have been processed by another thread.

   Thus this hint should only be combined with inplace IF each pixel retains its original position in the output and does not
   depend on the values of pixels in other rows.

   The host should create a copy of the instance for each thread. The copies should have duplicated output channels,
   thus the host can set the "offset" and "height" leaves for the channels to differing values for each thread. The copies
   may retain the origin in_parameters and in_channels.

   The instance passed to the thread with offset 0 should be the one used  by the host to make new copies.
   This means that the thread with offset 0 (the master thread) can update internal values each frame
   (provided the values are in stored in normal "plugin_*" leaves with fundamental types,
   and not in shared memory (allocated) pointed to), and the new values will be readable by all the threads on the subsequent frame.
   In this way the plugin may update its internal state consistently. 

   Note that voidptr values are copied by reference. Thus any internal data (allocated memory) referenced by VOIDPTR
   will still be shared, as will the in / out pixel_data (and audio data).

   Care must be taken if the filter has output parameters to ensure that only the master thread updates the values.

   Any thread may return an error code (plugin_invalid, filter_invalid, memory error, etc.) in which case the order of precedence
   of error values should be observed.
   e.g. if one thread returns plugin_invalid and another returns filter_invalid, the plugin_invalid takes precedence.



Tips for the Weed host.

Before setting the value of parameters from external sources it is best to check that the value match in both quantity and type.

For example:


SETTING PLUGIN PARAMETERS FROM EXTERNAL SOURCES

#include <weed/weed-host.h>
#include <weed.h>
#include <weed-effects.h>

#define MAX_PARAMS 256

static int ext_set_param(ext_context *ctx, int index, int nvalues, void *values) {
       // values should be a pointer to an array of correct size and type ; e.g  (void *)&(int[nvalues])

       weed_plan weed_plant_t *inst = (weed_plant_t *)ctx->priv_data;
       weed_plant_t *in_params[MAX_PARAMS];
       weed_plant_t *param;
       weed_size_t nparams, vsize;
       int32_t flags;

       if (index < 0 || index > MAX_PARAMS) return EINVAL;

       if (!inst) return (int)WEED_ERROR_NOSUCH_LEAF;

       nparams = weed_leaf_num_elements(inst, WEED_LEAF_IN_PARAMETERS);

        if (index >= nparams) {
	   return (int)WEED_ERROR_NOSUCH_ELEMENT;
	}

	for (i = 0; i < nparams; i++) {
	    weed_leaf_get(inst, WEED_LEAF_IN_PARAMETERS, i, &in_params[i]);
	}
  	if (in_params[index] == NULL) return FUBAR;

	/* try to get the existing number of values from "value", and if that doesn't exist, then from "default" */
  	vsize = weed_leaf_num_elements(param, WEED_LEAF_VALUE);
	if (!vsize) vsize = weed_leaf_num_elements(param, WEED_LEAF_DEFAULT);
      
	if (vsize > 0) {
    	   	  if (nvalues == vsize) {
		     	      /* Ok, that's the correct number of values, but we still need to check the type and then set the "value" */ 
      		     	      return validate_vals(param, 0, nvalues, value);
	}

  	flags = weed_get_int_value(param, WEED_LEAF_FLAGS, NULL);

  	if (flags & WEED_PARAMETER_VARIABLE_SIZE) {
	   	      		/* it's a list type value, the number of elements just has to an integer  multiple of the value size *\
				/* (i.e n * 3 for RGB, n * 4 for RGBA, n * 1 for everything else, n cam evem be zero)
      		     	      return validate_vals(param, vsize, nvalues, value);
	}

        // either the user tried to set an invalid number of elements or the plugin was misconfigured
	return EINVAL;

}








static int validate_values(weed_plant_t *param, int is_list, weed_size_t nvalues, void *value) {
        int hint;
	weed_size_t vsize - 1;
	int i;

	weed_leaf_get(param, WEED_LEAF_HINT, 0, &hint);

         if (hint == WEED_HINT_COLOR) {
	   	 int cspace;
    	        weed_leaf_get(param, WEED_LEAF_COLORSPACE, 1 &cspace)
		if (cspace == WEED_COLORSPACE_RGBA) vsize = 4; 
    		else vsize = 3;
	}

	if (( !is_list && nvalues != vsize ) || ( is_list && (nvalues % vsize) != 0) ) return EINVAL;

#ifndef CHECK_MIN_MAX
	weed_leaf_set(param, WEED_LEAF_VALUE, nvalues, value);
	return WEED_SUCCESS;
}
#endif

	// check for min / max (optional)



	if (hint == WEED_HINT_STRING || hint == WEED_HINT_SWITCH) {
	   	 // these types don't have min or max
	   	 weed_leaf_set(param, WEED_LEAF_VALUE, nvalues, valuie);
		 return WEED_SUCCESS;
	}

	if ((seed_type = weed_leaf_seed_type(param, WEED_LEAF_VALUE)) == WEED_SEED_INVALID)
	  	if ((seed_type = weed_leaf_seed_type(param, WEED_LEAF_DEFAULT))  == WEED_SEED_INVALID)
			seed_type = weed_leaf_seed_type(param, WEED_LEAF_NEW_DEFAULT);
		}
	}
	
	if (seed_type == WEED_SEED_INVALID) {
	   /* this is a spec error, plugin should at least set DEFAULT, (or NEW_DEAULT if it's an array) */
	   return EINVAL;
	}



		weed_size_t nvalsmin = weed_leaf_num_elements(param, WEED_LEAF_MIN);
		wed_size_t nvalsmax = weed_leaf_num_elements(param, WEED_LEAF_MIN);
		if (!is_list && (nvalsmin <  nvalues || nvalsmax < nvalues) return EINVAL;
		
		weed_size_t max_minmax = MAX(nvalsmin, nvalsmax);
		if (is_list) max_minmax = nvalues;

		if (max_minmax > 0) {
		   if (seed_type == WEED_SEED_INT) {
		      /* may be WEED_HINT_INTEGER or WEED_HINT_COLOR */
			      int **ivals = (int **)values; 
		   	      if (hint == WEED_HINT_INTEGER) {
			      	 int imin, imax;
				 if (is_list) {
				    if (nvalsmin) weed_leaf_get(param, WEED_LEAF_MIN, 0, &imin);
				    if (nvalsmax) weed_leaf_get(param, WEED_LEAF_MAX, 0, &imax);
				 }				    

				 for (i = 0; (weed_size_t)i < max_minmax; i++) {
				 	if (is_list || (weed_size_t)i < nvalsmin) {
				 	   	if (!is_list) weed_leaf_get(param, WEED_LEAF_MIN, i, &imin));
				      		if (*ivals[i] < imin) *ivals[i] = imin;
				 	}
				 	if (is_list || (weed_size_t)i < nvalsmax) {
				     	      	if (!is_list) weed_leaf_get(param, WEED_LEAF_MAX, i, &imax))
				      		if (*ivals[i] > imax) *ivals[i] = imax;
				 	}
				}
				else {
				     // WEED_HINT_COLOR
				     int imin_r, imin_g, imin_b, imin_a;
				     int imax_r, imax_g, imax_b, imax_a;
				     for (i = 0; (weed_size_t)i < max_minmax; i += vsize) {
				     
				     	 /* check MIN vals */
					 
				     	 if ( (is_list && i == 0) || (!is_list &&  (weed_size_t)i < nvalsmin) ) {
				     	    	 weed_leaf_get(param, WEED_LEAF_MIN, i, &imin_r); 
				           	 if (nvalsmin == 1) imin_g = imin_b = imin_r;
						 else {
						 	 weed_leaf_get(param, WEED_LEAF_MIN, i + 1, &imin_g); 
						 	 weed_leaf_get(param, WEED_LEAF_MIN, i + 2, &imin_b);
							 if (vsize == 4) weed_leaf_get(param, WEED_LEAF_MIN, i + 3, &imin_a);
						}
					if (is_list || (weed_size_t)i < nvalsmin) {
					   if (*ivals[i] < imin_r) *ivals[i] = imin_r;
					   if (*ivals[i + 1] < imin_g) *ivals[i + 1] = imin_g;
					   if (*ivals[i + 2] < imin_b) *ivals[i + 2] = imin_b;
					   if (vsize == 4 && nvalsmin > 1 && *ivals[i + 3] < imin_a) *ivals[i + 3] = imin_a;
					}

				     	 /* check MAX vals */
					 
				     	 if ( (is_list && i == 0) || (!is_list &&  i < nvalsmax) ) {
				     	    	 weed_leaf_get(param, WEED_LEAF_MAX i, &imax_r); 
				           	 if (nvalsmax == 1) imax_g = imax_b = imax_r;
						 else {
						 	 weed_leaf_get(param, WEED_LEAF_MAX, i + 1, &imax_g); 
						 	 weed_leaf_get(param, WEED_LEAF_MAX, i + 2, &imax_b);
							 if (vsize == 4) weed_leaf_get(param, WEED_LEAF_MAX, i + 3, &imax_a);
						}
					if (is_list || i < nvalsmax) {
					   if (*ivals[i] > imax_r) *ivals[i] = imax_r;
					   if (*ivals[i + 1] > imax_g) *ivals[i + 1] = imax_g;
					   if (*ivals[i + 2] > imax_b) *ivals[i + 2] = imax_b;
					   if (vsize == 4 && nvalsmax > 1 && *ivals[i + 3] > imax_a) *ivals[i + 3] = imax_a;
					}
				}					
		   }
		   else {
		   	/* must be WEED_SEED_DOUBLE */
		            /* may be WEED_HINT_FLOAT or WEED_HINT_COLOR */
			      double **dvals = (double **)values; 
		   	      if (hint == WEED_HINT_FLOAT) {
			      	 double fmin, fmax;
				 if (is_list) {
				    if (nvalsmin) weed_leaf_get(param, WEED_LEAF_MIN, 0, &fmin);
				    if (nvalsmax) weed_leaf_get(param, WEED_LEAF_MAX, 0, &fmax);
				 }				    

				 for (i = 0; i < max_minmax; i++) {
				 	if (is_list || (weed_size_t)i < nvalsmin) {
				 	   	if (!is_list) weed_leaf_get(param, WEED_LEAF_MIN, i, &fmin));
				      		if (*fvals[i] < fmin) *fvals[i] = fmin;
				 	}
				 	if (is_list || (weed_size_t)i < nvalsmax) {
				     	      	if (!is_list) weed_leaf_get(param, WEED_LEAF_MAX, &dmax))
				      		if (*dvals[i] > dmax) *dvals[i] = dmax;
				 	}
				}
				else {
				     // WEED_HINT_COLOR
				     double dmin_r, dmin_g, dmin_b, dmin_a;
				     double dmax_r, dmax_g, dmax_b, dmax_a;
				     for (i = 0; i < max_minmax; i += vsize) {
				     
				     	 /* check MIN vals */
					 
				     	 if ( (is_list && i == 0) || (!is_list &&  i < nvalsmin) ) {
				     	    	 weed_leaf_get(param, WEED_LEAF_MIN, i, &dmin_r); 
				           	 if (nvalsmin == 1) dmin_g = dmin_b = dmin_r;
						 else {
						 	 weed_leaf_get(param, WEED_LEAF_MIN, i + 1, &dmin_g); 
						 	 weed_leaf_get(param, WEED_LEAF_MIN, i + 1, &dmin_b);
							 if (vsize == 4) weed_leaf_get(param, WEED_LEAF_MIN, i + 1, &dmin_a);
						}
					if (is_list || (weed_size_t)i < nvalsmin) {
					   if (*dvals[i] < dmin_r) *dvals[i] = dmin_r;
					   if (*dvals[i + 1] < dmin_g) *dvals[i + 1] = dmin_g;
					   if (*dvals[i + 2] < dmin_b) *dvals[i + 2] = dmin_b;
					   if (vsize == 4 && nvalsmin > 1 && *dvals[i + 3] < dmin_a) *dvals[i + 3] = dmin_a;
					}

				     	 /* check MAX vals */
					 
				     	 if ( (is_list && i == 0) || (!is_list &&  (weed_size_t)i < nvalsmax) ) {
				     	    	 weed_leaf_get(param, WEED_LEAF_MAX, i, &dmax_r); 
				           	 if (nvalsmax == 1) dmax_g = dmax_b = dmax_r;
						 else {
						 	 weed_leaf_get(param, WEED_LEAF_MAX, i + 1, &dmax_g); 
						 	 weed_leaf_get(param, WEED_LEAF_MAX i + 2, &dmax_b);
							 if (vsize == 4) weed_leaf_get(param, WEED_LEAF_MAX, i + 3, &dmax_a);
						}
					if (is_list || (weed_size_t)i < nvalsmax) {
					   if (*dvals[i] > dmax_r) *dvals[i] = dmax_r;
					   if (*dvals[i + 1] > dmax_g) *dvals[i + 1] = dmax_g;
					   if (*dvals[i + 2] > dmax_b) *dvals[i + 2] = dmax_b;
					   if (vsize == 4 && nvalsmax > 1 && *dvals[i + 3] > dmax_a) *dvals[i + 3] = dmax_a;
					}
				}					



	weed_leaf_set(param








  if (nvalues % vsize != 0) {
    return EINVAL;
  }

  if (!validate_vals(param, nvalues, value)) {
    return EINVAL;
  }

  return 0;
}
