= Technical Specification =

Weed Audio Extension 1.1 final version.


(C) G. Finch 2005 - 2019

Version 1.1 - added "is_volume_master" to assist with host automation
of audio

22 Nov 2011 - clarified what kinds of channel patterns expected

05 Apr 2012 - if plugin has no audio it should send silence.



The Weed Audio Extension adds audio capabilities to the standard
WEED_PLANT_CHANNEL_TEMPLATE and WEED_PLANT_CHANNEL.




Generally, the following rules apply:

- an AUDIO channel template is declared in the plugin's weed_setup() function by setting the leaf "is_audio"
  to WEED_TRUE. That is all that needs to be done by the plugin, everything else is optional.

- audio is passed as arrays of (signed) float, with values nominally between 1.0 and -1.0

- each Weed audio channel may contain one or more audio subchannels (e.g mono, stereo, 5.1 etc).
  The default is (left, right) | (mono) 
  

- mixing video and audio within a single channel_template is not permitted. However, filters may contain any combination of video and
  audio channels, provided the video and audiio channels have separate templates. The host should follow the same rules
  for creating channels (ordering and number) regardles of whether a channel contains video or audio.

 The only major difference is the timing of procesing cycles:

- the process_func() of purely audio filters is usually called more frequently and at different times than for filters with video channels

  the host should update ALL of the (non disabled) channels for a plugin before running the processing cycle,
  and the plugin in turn should update ALL of the non disabled output channels. This means that if a filter has BOTH video
  and audio channels, then the host will likely run the plugin at the video rate and send and expect to receive comparatively
  larger packets of audio data (generally one video frame's worth) at a time.

- if an audio plugin has out parameters which are updated on each audio processing cycle,
  then due to these rate differences, it is quite likely that more than one audio cycle will occur before
  the video plugin has  a chance to read the values. See below (data passing between audio and video filters) for more
  discussion of this.


  Channel mapping:

mapping of subchannels -> channel layout (TBD)










== Filter_class ==

For filters with ONLY audio channels,  the "palette_list" leaf may be omitted or set to NULL.






Optional leaves:

the plugin may define these to inform the host, or it may leave them undefined.

The values in the channel should still be checked, since there is no guarantee that the host will always provide
audio in the format requested.




"min_audio_channels" : WEED_SEED_INT : (>= 1) the minimum number of audio subchannels. Eg, if set to 2 then the channel does not
		   		       	      	      	     accept mono. If set > 2 then it is mandatory to set the audio_channel_layout leaf.
							     If absent then a value of 1 (mono) is assumed.

T,B,D
"audio_channel_layout" :: WEED_SEED_INT64  ::  the plugin may define the set of (audio) channel layout(s) all  Weed auido channels.
		       
							It is envisaged that industry standard channel mapping names will be added to weed-compat.h
						 		    (channel_layout.h from the ffmpeg / libav project appears to be a good candidate).

					    If absent then STEREO, MONO is assumed.




"audio_rate" : WEED_SEED_INT : the preferred audio sample rate in Hz. May have multiple values and the host may select between them.
	       		       	   	     	   They should be listed in descending order of magnitude.
						   If absent then the host may provide audio data at any sample rate of its choosing.




Filter flags


*  WEED_FILTER_AUDIO_RATES_MAY_VARY
   Allows overriding of the default rate for individual channel templates. If the flag WEED_FILTER_IS_CONVERTER is set,
   allows resampling between in channels and out channels.


*  WEED_FILTER_AUDIO_CHANNELS_MAY_VARY
   Allows overriding of the default "audio_channel_layout" for channels by setting it in channel templates.
   If the flag WEED_FILTER_IS_CONVERTER is set, allows rempping / mixing of channels between in and out.


 * WEED_FILTER_IS_CONVERTER ::

 has multiple meanings depending on other settings.

 On its own it allows the plugin to remap audio subchannels with the audio layout (e.g swap left / right stereo).
 It also allows the plugin to combine / split multiple input channels into various output channels (depending on the number
 of in / out channels provided)
 
 However the channel layout and sample rate of each in / out channel must be the same.


- if "is_volume_master" is set for a parameter then the filter is an amplifier / volume control / volume mixer. etc/
  and the filter may also alter the volume.



- if WEED_FILTER_AUDIO_LAYOUTS_MAY_VARY is set, then the filter may change the layout mapping
  between input and output. The "audio_channels" and "audio_channel_maping" leaves in each channel_template define the
  set of possible transformations. (e.g mix down stereo to mono).



- if WEED_FILTER_AUDIO_RATES_MAY_VARY is set, then the filter may change the audio rate (resample) between inputs and outputs.



* WEED_FILTER_HINT_PROCESS_LAST
   This is a hint to the host that the filter should be run AFTER all other filters have performed their processing.
   Examples would be a video filter that overlays subtitles on the finished frame,
   or an audio filter that mixes the final output of several input audio channels. If there are several filters like this in
   the processing chain, then the host should decide the order to run them in.

experimental:
*  WEED_FILTER_HINT_MAY_THREAD
   If an audio  plugin operates in such a manner that its output may be subdivided into consecutive blocks of samples,
   then it may set this hint. Ignored for filters which have no out_channels.
   Similar to the method used for video filters, process_func() will be called several times with the same timecode,
   and an extra "offset" leaf added to the out channel(s). This value gives the value in samples from the start of each
   subchannel in "audio_data" that the thread should work on. "audio_data_length" will contain 2 values, the first is
   the reduced data length for the thread - the thread should only write to output "audio_data" from
   offs to offs + audio_data_lenght - 1. The second value in "audio_data_length" contains the true value.
   AS with video threading, the thread with offset 0 is considered the "master thread" and should be the only one which
   updates plugin internal values.


PROCESS_LAST





=== Channel template ===

Additional Mandatory leaves:

"is_audio" : WEED_SEED_BOOLEAN : if set to WEED_TRUE, then this channel is audio.

=== Optional leaves ===
If the filter set the filter class flag WEED_FILTER_AUDIO_CHANNELS_MAY_VARY,
then the plugin may define these in channel templates to override the defaults for the filter. Otherwise they may be ignored.

The values in the channel should still be checked, since there is no guanrantee that the host will always provide
audio in the format requested.

"audio_channels" : WEED_SEED_INT : the desired number of audio channels in the audio_data : 1 = (mono), 2 = stereo, etc.											May have multiple values and then the host can select the value
		   		       	      	      	     should be listed in DESCENDING order of magnitude.
							     A setting of zero means this particular channel has no preferred number,
							     overriding any default setting in the filter class.



T,B,D
"audio_channel_layout" :: the plugin may define the (audio) channel layout for the Weed chanel.

					    It is envisaged that standard channel mapping names will be added to weed-compat.h
					    


If the filter set the flags  WEED_FILTER_AUDIO_RATES_MAY_VARY

"audio_rate" : WEED_SEED_INT : the preferred audio sample rate in Hz. May have multiple values and the host may select between them.
	       		       	   	     	   They should be listed in DECREASING order of magnitude.
						   if set to zero then this channel has no restrictions (overriding the default set in the filter_class)





Channel template flags:


  * WEED_CHANNEL_OPTIONAL
    channel that can be left out at initialization time.
    the host decides not to use the channel, it must set "disabled" to
    WEED_TRUE for the channel. The host must reinit
    the instance if a channel is enabled or disabled after init_func().

 *  WEED_CHANNEL_CAN_DO_INPLACE    [[BR]]
    If this flag bit is set, the filter can do inplace operations (source and destination are the same)
    Hosts can select this mode by setting "audio_data" of this out channel
    equal to "audio_data"  of the corresponding (same number; not counting "disabled" channels) 
    in channel. The values of "audio_data_length", "audio_channels", "audio_interleaf" and "audio_rate" must be equal
    for both channels.
    The flag bit is only valid for OUT channels. 



If the plugin needs reiniting when the audio RATE changes, then it should set the flag bit
WEED_CHANNEL_REINIT_ON_AUDIO_RATE_CHANGE (alias for WEED_CHANNEL_REINIT_ON_SIZE_CHANGE).

If the plugin needs reiniting when the audio CHANNEL LAYOUT changes, then it should set the flag bit
WEED_CHANNEL_REINIT_ON_AUDIO_LAYOUT_CHANGE  (alias for WEED_CHANNEL_REINIT_ON_PALETTE_CHANGE)





== WEED_PLANT_CHANNEL ==



Additional Mandatory leaves for CHANNELS with audio - these values are set by the host:

"audio_data" : WEED_SEED_VOIDPTR : stores a pointer to 32 bit signed float data for
	       			      audio buffer. Values within the buffer are nominally in the range -1.0 <=
	  			           value <= 1.0. [can be NULL if the host has no audio to pass].

"audio_data_length" : WEED_SEED_INT : length of audio_data in samples
                                      [can be 0 if the host has no audio to pass]. The length may vary on each cycle, but if the plugin set
				      audio_data_length in





"audio_channels" : WEED_SEED_INT : number of audio channels in the audio_data : must be >=1 (mono), 2==stereo, etc.


"audio_rate" : WEED_SEED_INT : the audio sample rate in Hz. 


T,B,D
"audio_channel_layout" :: the host may set this to define the channel mapping for the channel.
			       	    	   If absent then it may be assumed 1 == MONO. 2 == STEREO (LEFT, RIGHT)

					    It is envisaged that standard channel layout names will be added to weed-compat.h



Notes:

Audio data should be passed to and from the host as an arrary of WEED_SEED_VOIDPTR
(cast from float *), with each channel's data in a separate element.

In the case that the host has no audio for a Weed channel, it can pass NULL for the data and 0 for the size.

In the case that the host has no audio for a subchannel (i.e within the same Weed channel)
it should fill the subchannel data element with (float) 0.0. (i.e. silence).


The values for "audio_channels", "audio_rate", and "audio_interleaf" MUST be set equal for all channels, in and out, unless:
if the plugin sets WEED_FILTER_AUDIO_RATES_MAY_VARY in filter flags then
the audio sample rate and hence the audio_data_length for each channel may vary. The plugin can override the filter defaults
by setting individual values in channel templates. Plugins MUST NOT alter the sample rate between input and output UNLESS:

if the filter flag WEED_FILTER_IS_CONVERTER is set then the plugin is a resampling plugin and it MUST convert the sample rate
between each input channel and the corresponding output channel.



if the plugin sets WEED_FILTER_AUDIO_LAYOUTS_MAY_VARY in filter flags then
the audio channel layout for each Weed channel may vary. The plugin can override the filter defaults
by setting individual values in channel templates.
Plugins MUST NOT alter the channel layout between input and output UNLESS:

if the filter flag WEED_FILTER_IS_CONVERTER is set then the plugin  MUST convert the channel layout between in and out.
In addition it may mix multiple audio in channels into the output channels.









== WEED_PLANT_PARAMETER_TEMPLATE ==

"is_volume_master" : WEED_SEED_BOOLEAN :

effects which vary the volume (magnitude) of the audio must set the flag WEED_FILTER_IS_CONVERTER.
They must also provide a volume control for the host.

The plugin is allowed to provide only one such parameter per filter.

Such a parameter must be a float, and must *linearly* adjust the volume produced at the output between 0.0 (silence)and 1.0
(unamplified output)  (i.e it is a simple multiplier of the output.
(the maximum may optionally be set higher to allow for extra amplification).

The plugin may optionally provide additional functionality (e.g pan, eq, filtering, remapping of subchannels left / right, etc).

This leaf can be combined with the flag WEED_PARAMETER_VALUE_PER_CHANNEL
This implies that the parameter has multiple values and that each value maps directly to a Weed input channel.

If the filter has repeating channels ("max_repeats"), then the flag WEED_PARAMETER_VARIABLE_SIZE should also be set to
allow the number of values to increase or decrease according to the number of channels created from tha template.

An audio filter may also set the flag WEED_FILTER_PROCESS_LAST, which would imply that it may be run as the final mixing
filter before the resulting audio is sent to the audio player.


"is_transition" :
similar meaning as for video only filters. If the filter provides exactly 2 in audio channels and one out then this parameter
will define the mix between the first in channel and the second provided at the output.

  		    at min the effect is fully "off", reproducing only the audio from channel 0 at the output.
		    at max it is fully "on", reproducing only the audio from the second audio in channel

		    Only one parameter may have this leaf, it must be a single valued parameter of type integer or float,
		    and the plugin must have exactlty two mandatory input channels and mandatory output channel.
		    Otherwise this leaf is ignored.
		    Valid only for in parameters.

		    IF the filter also has video channels the this parameter must also control the video transition.










Passing data between audio and video filters.

    For example:
    - a "beat detector" plugin creates THREE output parameters: a boolean (switch) "beat pulse" parameter,
      a boolean "beat latch" (or an integer "beat count"), and an integer "read count" parameter.

      it also creates an input parameter, "read count" with a default value of zero.

      The beat pulse output may be updated on each audio cycle. This output can be fed into other audio filters by the host.

      The second output parameter is either set to WEED_TRUE when a beat is detected, or the count may be incremented,
      depending on the type of parameter desired.

      The plugin should examine the value of the "read count" input parameter, and if it has increased it can reset the "beat latch"
      and finally, it can copy the new value of "read count" to the output parameter "read count".

      When the video cycle runs, each video plugin can read the value of the second parameter to know if (or how many) beats
      were detected since the last video cycle, It can then take the value from the "read count" output, increment it, and feed it
      back into the audio filter's input "read count", to signal that it has read the value. Obviously if another audio cycle is triggered
      partway through the vidoe cycle, not all video filters will have a chance to read the updated value. If this is an issue then it can be
      set up so that only the first video filter reads and updates the audio filter, and the first video filter mirrors the value read as an
      output parameter for the remaining video filters to read. 

      Another solution might be for a single plugin to create both pure video and pure audio filters. These filters can then be connected
      internally within the plugin.



