= Technical Specification =

Weed Audio Extension 1.1 final version.


(C) G. Finch 2005 - 2019

Version 1.1 - added "is_volume_master" to assist with host automation
of audio

22 Nov 2011 - clarified what kinds of channel patterns expected

05 Apr 2012 - if plugin has no audio it should send silence.



The Weed Audio Extension adds audio capabilities to the standard
WEED_PLANT_CHANNEL_TEMPLATE and WEED_PLANT_CHANNEL.




Generally, the following rules apply:

- an AUDIO channel template is declared in the plugin's weed_setup() function by setting the leaf "is_audio"
  to WEED_TRUE. That is all that needs to be done by the plugin, everything else is optional.

- audio is passed as arrays of (signed) float, with values nominally between 1.0 and -1.0

- mixing video and audio within a single channel_template is not permitted. However, filters may contain any combination of video and
  audio channels, provided the video and audiio channels have separate templates. The host should follow the same rules
  for creating channels (ordering and number) regardles of whether a channel contains video or audio.

 The only major difference is the timing of procesing cycles:

- the process_func() of purely audio filters is usually called more frequently and at different times than for filters with video channels

  the host should update ALL of the (non disabled) channels for a plugin before running the processing cycle,
  and the plugin in turn should update ALL of the non disabled output channels. This means that if a filter has BOTH video
  and audio channels, then the host will likely run the plugin at the video rate and send and expect to receive comparatively
  larger packets of audio data (generally one video frame's worth) at a time.

- if an audio plugin has out parameters which are updated on each audio processing cycle,
  then due to these rate differences, it is quite likely that more than one audio cycle will occur before
  the video plugin has  a chance to read the values. See below (data passing between audio and video filters) for more
  discussion of this.


  Channel layouts:

- The plugin can choose whether all audio subchannels (e.g. left / right / center) are passed in one Weed channel,
  or whether each subchannel is passed separately, i.e one Weed channel maps to left, another to right, etc.

  Obviously, if the plugin accepts multiple audio streams then it is better to have each Wed channel map to an entire stream.
  If the plugin only handles a single audio stream, then it may prefer to have each auido subchannel map to a separate Weed channel
  (e.g in the case of a stereo input, the left audio channel might map to in_channel[0] and the right audio channel to in_channel[1].

 Thus, the plugin requires some means to notify the host. For this the plugin can set the "audio_channel_layout" leaf in the filter class.
 This leaf may contain one or more values (if more than one then the host may select between them).

 However, this still doesn't tell the host whether the mapping is for each audio channel (Iin the case of plugins with multiple in and
 put channels) or whether the mapping defines the role of each individual channel. By default it should be asssumed that the
 mapping is to be applied to each individual channel (in or out).

The plugin may do two things to override the default. First it may set the "audio_channels" leaf to 1 iin the filter class. Obviously if
the channel layout contains multiple audio channels, but each Weed channel can only contain one, then the mapping applies to
the filter as a whiole. However the "role" of each channel is still undefined. To define this, the plugin may set the flag:
WEED_FILTER_AUDIO_CHANNELS_MAY_VARY in the filter flags. This then allows the plugin to set "audio_channel_layout"
leaves with unique values in the channel _templates. In this way the mapping is fully defined for the host.

There are a few more subtleties to this which are discussed below.

If the plugin sets nothing for a filter, then the default is that the host may send either mono or stereo audio, to the first audio channel
and set value of the "audio_channels" leaf  to either 1 or 2. In this case "audio_data" [0] is left or mono, whilst "audio_data" [1] is right.


The following decision tree may assist with the plugin setup.

Does the plugin want to have audio in_channel(s) ?

No => do nothing, maybe create some video inputs.

Yes => create at least one in_channel template with the leaf "is_audio" set to WEED_TRUE. It is not necesassary to create "palette_list"
       	      	for te filter.
		
             channels created from this may not have video

=> all audio channels in one, or separate ?


all in one: do nothing and receive mono or stereo in first audio channel.


maybe make the channel optional

maybe set "max_repeats" to allow multiple streams

maybe set WEED_FILTER_IS_CONVERTER if it wants to mix input streams into one output stream

maybe set "is_volume_master" in one parameter to denote the global volume (gain) control for all inputs

maybe set WEED_PARAMETER_VALUE_PER_CHANNEL if the volume  master has one value per input stream





separate:
set "audio_channels" to 1, provide "channel_template_layout"


set flag WEED_FILTER_AUDIO_CHANNELS_MAY_VARY

set "audio_channel_layout" in each template


Possibly Make some channels optional.

Possibly put multiple values in "audio_channel_layout"













== Filter_class ==

For filters with ONLY audio channels,  the "palette_list" leaf may be omitted or set to NULL.






Optional leaves:

the plugin may define these to hint them for the host, or it may leave them undefined.

The values in the channel should still be checked, since there is no guarantee that the host will always provide
audio in the format requested.

It is highly recommended that the plugin leave these values undefined whenever possible, since complying with them
will possibly result in a performance hit for the host.



"audio_channels" : WEED_SEED_INT : (>= 1) the desired number of audio channels in the audio_data : 1 = (mono), 2 = stereo, etc.									May have multiple values and then the host can select the value
		   		       	      	      	     should be listed in DESCENDING order of magnitude.
							     IF absent then the host may freely set the number of audio channels itself.
							     The plugin should check the number of elements in "audio_data".


T,B,D
"audio_channel_mapping" :: the plugin may define the (audio) channel mapping for the Weed channels.
			       	      	    The values in this leaf should align one for one with the values in "audio_channels",
					    that leaf is MANDATORY if this one exists.
					    It is envisaged that industry standard channel mapping names will be added to weed-compat.h
					    (channel_layout.h from the ffmpeg / libav project appears to be a good candidate).

					    If this leaf is absent, then a channel number of 1 in "audio_channels" is assumed to mean
					    MONO and a value of 2 is assumed to mean STEREO.




"audio_rate" : WEED_SEED_INT : the preferred audio sample rate in Hz. May have multiple values and the host may select between them.
	       		       	   	     	   They should be listed in descending order of magnitude.
						   If absent then the host may provide audio data at any sample rate of its choosing.




Filter flags


*  WEED_FILTER_AUDIO_RATES_MAY_VARY (alias for WEED_FILTER_CHANNEL_SIZES_MAY_VARY)
   Allows overriding of the default rate for individual channel templates.


*  WEED_FILTER_AUDIO_CHANNELS_MAY_VARY (alias for WEED_FILTER_PALETTES_MAY_VARY)
   Allows overriding of the default number of (audio) channels in channel templates.


* WEED_FILTER_HINT_PROCESS_LAST
   This is a hint to the host that the filter should be run AFTER all other filters have performed their processing.
   Examples would be a video filter that overlays subtitles on the finished frame,
   or an audio filter that mixes the final output of several input audio channels. If there are several filters like this in
   the processing chain, then the host should decide the order to run them in.

experimental:
*  WEED_FILTER_HINT_MAY_THREAD
   If an audio  plugin operates in such a manner that its output may be subdivided into consecutive blocks of samples,
   then it may set this hint. Ignored for filters which have no out_channels.
   Similar to the method used for video filters, process_func() will be called several times with the same timecode,
   and an extra "offset" leaf added to the out channel(s). This value gives the value in samples from the start of each
   subchannel in "audio_data" that the thread should work on. "audio_data_length" will contain 2 values, the first is
   the reduced data length for the thread - the thread should only write to output "audio_data" from
   offs to offs + audio_data_lenght - 1. The second value in "audio_data_length" contains the true value.
   AS with video threading, the thread with offset 0 is considered the "master thread" and should be the only one which
   updates plugin internal values.



=== Channel template ===

Additional Mandatory leaves:

"is_audio" : WEED_SEED_BOOLEAN : if set to WEED_TRUE, then this channel is audio.

=== Optional leaves ===
If the filter set the filter class flag WEED_FILTER_AUDIO_CHANNELS_MAY_VARY,
then the plugin may define these in channel templates to override the defaults for the filter. Otherwise they may be ignored.

The values in the channel should still be checked, since there is no guanrantee that the host will always provide
audio in the format requested.

"audio_channels" : WEED_SEED_INT : the desired number of audio channels in the audio_data : 1 = (mono), 2 = stereo, etc.											May have multiple values and then the host can select the value
		   		       	      	      	     should be listed in DESCENDING order of magnitude.
							     A setting of zero means this particular channel has no preferred number,
							     overriding any default setting in the filter class.



T,B,D
"audio_channel_mapping" :: the plugin may define the (audio) channel mapping for the Weed chanel.
 			       	      	  If set, then it must match one for one with the value(s) in "audio_channels" (either for the
					  filter_class or the channel_template).

					    It is envisaged that standard channel mapping names will be added to weed-compat.h
					    


If the filter set the flags  WEED_FILTER_AUDIO_RATES_MAY_VARY

"audio_rate" : WEED_SEED_INT : the preferred audio sample rate in Hz. May have multiple values and the host may select between them.
	       		       	   	     	   They should be listed in DECREASING order of magnitude.
						   if set to zero then this channel has no restrictions (overriding the default set in the filter_class)





Channel template flags:


  * WEED_CHANNEL_OPTIONAL
    channel that can be left out at initialization time.
    the host decides not to use the channel, it must set "disabled" to
    WEED_TRUE for the channel. The host must reinit
    the instance if a channel is enabled or disabled after init_func().

 *  WEED_CHANNEL_CAN_DO_INPLACE    [[BR]]
    If this flag bit is set, the filter can do inplace operations (source and destination are the same)
    Hosts can select this mode by setting "audio_data" of this out channel
    equal to "audio_data"  of the corresponding (same number; not counting "disabled" channels) 
    in channel. The values of "audio_data_length", "audio_channels", "audio_interleaf" and "audio_rate" must be equal
    for both channels.
    The flag bit is only valid for OUT channels. 



If the plugin needs reiniting when the audio RATE changes, then it should set the flag bit
WEED_CHANNEL_REINIT_ON_RATE_CHANGE (alias for WEED_CHANNEL_REINIT_ON_PALETTE_CHANGE).

If the plugin needs reiniting when the audio CHANNELS change, then it should set the flag bit
WEED_CHANNEL_REINIT_ON_CHANNELS_CHANGE  (alias for WEED_CHANNEL_REINIT_ON_SIZE_CHANGE)

If the plugin needs reiniting when the audio CHANNEL MAPPING change, then it should set the flag bit
WEED_CHANNEL_REINIT_ON_CHANNEL_MAP_CHANGE  (alias for WEED_CHANNEL_REINIT_ON_ROWSTRIDES_CHANGE)







== WEED_PLANT_CHANNEL ==



Additional Mandatory leaves for CHANNELS with audio - these values are set by the host:

"audio_data" : WEED_SEED_VOIDPTR : stores a pointer to 32 bit signed float data for
	       			      audio buffer. Values within the buffer are nominally in the range -1.0 <=
	  			           value <= 1.0. [can be NULL if the host has no audio to pass].

"audio_data_length" : WEED_SEED_INT : length of audio_data in samples
                                      [can be 0 if the host has no audio to pass]. The length may vary on each cycle, but if the plugin set
				      audio_data_length in




"audio_interleaf" : WEED_SEED_BOOLEAN : if WEED_TRUE, then audio channels are interleaved (deprecated)

"audio_channels" : WEED_SEED_INT : number of audio channels in the audio_data : must be >=1 (mono), 2==stereo, etc.

"audio_rate" : WEED_SEED_INT : the audio sample rate in Hz. 


T,B,D
"audio_channel_mapping" :: the host may set this to define the channel mapping for the channel.
			       	    	   If absent then it may be assumed 1 == MONO. 2 == STEREO

					    It is envisaged that standard channel mapping names will be added to weed-compat.h



Notes:

Audio data should be passed to and from the host as an arrary of WEED_SEED_VOIDPTR
(cast from float *), with each channel's data in a separate element.

In the case that the host has no audio for a Weed channel, it can pass NULL for the data and 0 for the size.

In the case that the host has no audio for a subchannel (i.e within the same Weed channel)
it should fill the subchannel data element with (float) 0.0. (i.e. silence).


The values for "audio_channels", "audio_rate", and "audio_interleaf" MUST be set equal for all channels, in and out, unless:
if the plugin sets WEED_FILTER_AUDIO_RATES_MAY_VARY in filter flags then
the audio sample rate and hence the audio_data_length for each channel may vary. The plugin can override the filter defaults
by setting individual values in channel templates. Plugins MUST NOT alter the sample rate between input and output UNLESS:

if the filter flag WEED_FILTER_IS_CONVERTER is set then the plugin is a resampling plugin amd it MUST convert the sample rate
between each input channel and the corresponding output channel.



if the plugin sets WEED_FILTER_AUDIO_CHANNELS_MAY_VARY in filter flags then
the audio channels for each Weed channel may vary. The plugin can override the filter defaults
by setting individual values in channel templates.
Plugins MUST NOT alter the number of audio channels between input and output UNLESS:

if the filter flag WEED_FILTER_IS_CONVERTER is set then the plugin is a channel combining plugin and it MUST convert the number of
audio channels between each input channel and the corresponding output channel.






== WEED_PLANT_PARAMETER_TEMPLATE ==

"is_volume_master" : WEED_SEED_BOOLEAN :


for  effects which vary the volume (magnitude) of all the inputs as a whole,
exactly one of the parameter templates must be marked by setting the leaf "is_volume_master" to WEED_TRUE.
This is to allow for host automation.

Such a parameter must be a float, and must *linearly* adjust the volume for ALL audio input channels
between 0.0 (silence) and 1.0 (no amplification).


The maximum may optionally go beyond 1.0 (for amplifier/pre-amp) type plugins). A setting above 1.0 implies that the plugin
is controlling some hardware device. The actual audio data should never be adjusted ABOVE its input value (to prevent clipping).

"linearly" means that at value 0.5, an input with 1.0 would result in an output of 0.5, and input of 0.5 would result in .25 etc.
In other words, values between 0.0 and 1.0 should be applied as a simple multiplier of the output channel(s)

The plugin may optionally provide additional functionality (e.g pan, eq, filtering).


This leaf can be combined with the flag WEED_PARAMETER_VALUE_PER_CHANNEL
This implies that the parameter has multiple values and that each value maps directly to a Weed input channel.
If the filter has repeating channels ("max_repeats"), then the flag WEED_PARAMETER_VARIABLE_SIZE should also be set to
allow the number of values to increase or decrease according to the number of channels created from tha template.



Setting the filter template flag bit WEED_FILTER_IS_CONVERTER in combination with the leaf implies that the purpose
of the plugin is to alter the overall volume between input and output, ie.
a volume control (for a single input / single output), a mixer (multiple inputs, single output),
or a channel level controller (multi inputs, multi outputs). In this case the value controls the volume of all of the OUTPUT channel(s).
IF WEED_PARAMETER_VALUE_PER_CHANNEL is set then multiple values may be used to set individual values per output channel.


An audio filter may also set the flag WEED_FILTER_PROCESS_LAST, which would imply that it may be run as the final mixing
filter before the resulting audio is sent to the audio player.


To recap:
the filter template flag bit WEED_FILTER_IS_CONVERTER has multiple meanings depending on other settings.

- if "is_volume_master" is set for a parameter then the filter is an amplifier / volume control / volume mixer. etc/

- if WEED_FILTER_AUDIO_CHANNELS_MAY_VARY is set, then the filter may change the number of channels (as in audio sub channels)
  between each input and output. The "audio_channels" and "audio_channel_maping" leaves in each channel_template define the
  set of possible transformations.

- if WEED_FILTER_AUDIO_RATES_MAY_VARY is set, then the filter may change the audio rate (resample) between inputs and outputs.
  between each input and output




Passing data between audio and video filters.

    For example:
    - a "beat detector" plugin creates THREE output parameters: a boolean (switch) "beat pulse" parameter,
      a boolean "beat latch" (or an integer "beat count"), and an integer "read count" parameter.

      it also creates an input parameter, "read count" with a default value of zero.

      The beat pulse output may be updated on each audio cycle. This output can be fed into other audio filters by the host.

      The second output parameter is either set to WEED_TRUE when a beat is detected, or the count may be incremented,
      depending on the type of parameter desired.

      The plugin should examine the value of the "read count" input parameter, and if it has increased it can reset the "beat latch"
      and finally, it can copy the new value of "read count" to the output parameter "read count".

      When the video cycle runs, each video plugin can read the value of the second parameter to know if (or how many) beats
      were detected since the last video cycle, It can then take the value from the "read count" output, increment it, and feed it
      back into the audio filter's input "read count", to signal that it has read the value. Obviously if another audio cycle is triggered
      partway through the vidoe cycle, not all video filters will have a chance to read the updated value. If this is an issue then it can be
      set up so that only the first video filter reads and updates the audio filter, and the first video filter mirrors the value read as an
      output parameter for the remaining video filters to read. 

      Another solution might be for a single plugin to create both pure video and pure audio filters. These filters can then be connected
      internally within the plugin.




Audio channel -> Weed channel mapping






e.g.
in_channel[0] -> audio_data : float *data[0]       ==  left / mono
in_channel[1] -> audio_data : float *data[0]       ==  right      (optional)

or using "max_repeats"
in_channel[0] -> audio_data : float *data[0]       ==  subchannel[0] data

....

in_channel[n] -> audio_data : float *data[0]       ==  subchannel[n] data


On the other hand, if the plugin deals with multiple audio streams, it is better to create one Weed channel for each stream,
with the audio passed in an array of float * with multiplle elements containing the audio subchanels, eg:

e.g.
in_channel[0] -> audio_data : float *data[0]       ==  stream 0 left / mono
in_channel[0] -> audio_data : float *data[1]       ==  stream 0 right
in_channel[0] -> audio_data : float *data[2]       ==  stream 0 center
etc.

in_channel[1] -> audio_data : float *data[0]       ==  stream 1   	left / mono
in_channel[1] -> audio_data : float *data[1]       ==  stream 1   	right
in_channel[1] -> audio_data : float *data[1]       ==  stream 1    	center
etc.


or using "max_repeats"
in_channel[0] -> audio_data : float *data[0]       ==  stream 0 left / mono
in_channel[0] -> audio_data : float *data[1]       ==  stream 0 right
in_channel[0] -> audio_data : float *data[2]       ==  stream 0 center
etc.

in_channel[n] -> audio_data : float *data[0]       ==  stream n   	left / mono
in_channel[n] -> audio_data : float *data[1]       ==  stream n   	right
in_channel[n] -> audio_data : float *data[1]       ==  stream n    	center
etc.


The plugin should create an equivalent number of output channels as input channels, except - 
If it wishes to combine the inputs into a single output
(e.g mix down to stereo) then it must also set the filter flag WEED_FILTER_IS_CONVERTER. This is explained in more detail below.

